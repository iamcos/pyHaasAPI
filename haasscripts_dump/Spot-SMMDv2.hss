-- Version 2
-- Date 27 Sept 22, 16:37:52
-- Kobalt:SPOTIFIED TRAILING MODified Frogg mod version of Phsai's amazing Simple Market Maker and Smokyho's BFH Mod
-- Trend following mods by Fogg
-- Bot mod is intended to trade with the trend instead of against as previous SMMs were designed
-- Made to hedge on Binance/Bybit but but can be used on BYBIT with one bot long and one bot short
-- (ex. Longs enabled on BTCPERP and Shorts enabled on BTC0930/Quarterlies)
-- Consider donating to support our work!
-- Phsai 
    -- BTC : 1MTEdma4LgdN2hSadRppeZ6PxsyXQNuxS2
    -- USDT: 0x2f052efde92ded10e05e00277f4a5cdfd9c280ca
-- Smokyho 
   --
    -- USDT: 0x7720A90d0D1973eFcc258b91450c51c9967e110A
-- Fogg
    -- BTC : xxx
    -- USDT: xxx
--Kobalt :return to Frogg wallet x_0
----------------------------------------------------------------------------
Log('Trend Following mod v1') 
EnableHighSpeedUpdates(true)
HideOrderSettings()
HideTradeAmountSettings()
 
-- Check BYBIT or BINANCE or WHATEVER SPOT TRADING
    local getMarket = PriceMarket();
    local exchangeCode = StringSplit(getMarket, "_")[1]
   
-- inputs
    InputGroupHeader('Trade Settings')
    local okLong = Input('Allow Long', true, 'Allow bot to open Long')
    local okShort = Input(' Allow Short', true, 'Allow bot to open Short')
    local wtfStop = Input('  Stop at no position', false, 'Deactivate bot when there is no open position')
    
    InputGroupHeader('Backtest Settings')
    local wtfBal = Input('Deactivate on Over Budget', false, 'Deactivate when Bal Ratio hit 1')
    local wtfRatio = Input(' Deactivate on specific Bal Ratio', false, 'Deactivate when Bal Ratio hit trigger below')
    local wtfRatioV = Input('  Bal Ratio Trigger', 1)
    local wtfAmount = Input('   Deactivate on Over Size', false, 'Deactivate when one of position size > Max Open')
    local compound = Input('   Add profit into balance', false, 'ONLY FOR BACKTEST. DO NOT USE WHEN ON RUNNING BOT')
    local testWallet = Input('    Use Custom Wallet', false, 'ONLY FOR BACKTEST. DO NOT USE WHEN ON RUNNING BOT')
    local testBal = Input('     Custom Wallet Balance', 8000, 'ONLY FOR BACKTEST. DO NOT USE WHEN ON RUNNING BOT')
    
    InputGroupHeader('Budget & Safety')
    local maxSizeM = Input('Max. Open Contracts', 0.5, 'Maximum open contracts at any given time also as minimum for Dynamic Max Open. After exceeding this value, the bot will dump a portion of position at a loss.')
    local autoMax = Input(' Dynamic Max Open', false, 'Dynamically change max open contracts based on available balanca')
    local leverage = Input('  Leverage', 1, 'MUST be filled even if using Cross Margin. Important for trading budget.')
    local contVal = Input('   COIN-M Value', 10, 'ONLY if bot trading on INVERSE Futures then enter the Contract Value. Ignore if trade on USDT') 
    local maxBudget = Input('    Balance Budget', 1, 'How much from wallet balance allocated for this bot. 0.5 is 50% of wallet balance.')
    local maxOpen = Input('     Position Budget', 0.8, 'How much from the Balance Budget allocated for opening positions. 0.1 is 10% of Balance Budget')
    local reduceSize = Input('      Size Reduction %', 10, 'How big of a portion the bot will dump once Max. Open Contracts is exceeded')
    local reduceOrderType = InputOrderType('     Reduction Order Type', MakerOrCancelOrderType, 'The order type for size reduction dump')
    local noReduce = Input('         Disable Size Reduction', true, 'Are you sure?')
 
    InputGroupHeader('Grid Settings')
    local slotCount = Input('Slot Count', 10, 'How many orders are constantly kept open on both long and short side')
    local slotSizeM = Input(' Slot Size', 0.05, 'Trade amount per slot')
    local autoSlot = Input('  Dynamic Slot Size', false, 'DSSize - Dynamically change slot size favoring trending side.')
    local slotBudget = Input('   Max. Open Divider', 333, 'DSSize feature - Divide max open position with this value to get new Slot Size. Example Max Open is 1000 and devider is 200 then slot size is 5') 
    local slotSpread = Input('    Slot Spread %', 0.64, 'Percentage based spread value between each slot')
    local slotCancel = Input('     Cancel Distance %', 1.2, 'How much price can move to the opposite direction before orders are cancelled and replaced')
    local minSpread = Input('     Minimum Spread %', 0.14, 'Minimum spread percentage between the first long and short entries. This setting only works when bot has no position.')
    local dynamicSpreadInterval = InputInterval("07. Dynamic Spread Interval", 15)
    local dynamicSpreadLookback = Input("07A. Dynamic Spread Lookback", 3)
    
    InputGroupHeader('Hull Trend Settings')
    local hulltime = InputInterval('Hull MA Interval', 6, 'Timeframe for Hull MA')
    local period_ma1 = Input('  MA1 Length', 14, 'Short Hull MA Period')
    local period_ma2 = Input('   MA2 Length', 33, 'Long Hull MA Period')
    local ma_type1 = InputMaTypes('    MA1 Type', WmaType, 'Short Hull MA Type')
    local ma_type2 = InputMaTypes('     MA2 Type', WmaType, 'Long Hull MA Type')

    InputGroupHeader('Profit Settings')
    local tp_type = InputOptions('Take-Profit Type', 'Trailing', {'Fixed', 'Trailing'})
    local takeProfit = Input('Fixed TP %', 0.5, 'Fixed take-profit value, based on price change')
    local trail_min_profit = Input('Trailing Minimum Profit %', 0.4)
    local trail_dist = Input('Trailing Distance', 0.2)
    local takeProfitL = Input('LONG Take-Profit %', 0.6, 'Fixed take-profit value, based on price change')
    local takeProfitS = Input(' SHORT Take-Profit %', 0.6, 'Fixed take-profit value, based on price change')
    local tpOrderType = InputOrderType(' FPPTPOP: Fixed Pre-Placed TP Order Type', MakerOrCancelOrderType, 'The order type for fixed pre placed take-profit')
    local preplacedTP = Input('   Pre-Place TP', true, 'Place fixed Exit Position as soon as has open position')


--Dynamic Spread 
    local candleSpread = HighPrices(dynamicSpreadInterval) - LowPrices(dynamicSpreadInterval)
    local candleSpreadWithLookback = Range(candleSpread, 0, dynamicSpreadLookback)
    local averageSpread = Round(Average(candleSpreadWithLookback), 8)
    local averageSpreadPercentage = Round(averageSpread / CurrentPrice().close * 100, 4)

    Log("Dynamic Average Spread: "..averageSpread.." "..QuoteCurrency())
    Log("Dynamic Average Spread: "..averageSpreadPercentage.."%")
-- 
    minSpread = minSpread / 2.0
 
local SRCounter = Load('SRCounter', 0)
 
-- price and data
            local cp = CurrentPrice()
            local c = ClosePrices()
            local trendprices = ClosePrices(hulltime)
            local ma1 = CC_HMA(trendprices, period_ma1, ma_type1)
            local ma2 = CC_HMA(trendprices, period_ma2, ma_type2)
 
        -- positions
            local hedge_longPosId = Load('hedge_longPosId', NewGuid())
            local hedge_shortPosId = Load('hedge_shortPosId', NewGuid())
 
            local dir_l = GetPositionDirection(hedge_longPosId)
            local aep_l = GetPositionEnterPrice(hedge_longPosId)
            local pamt_l = GetPositionAmount(hedge_longPosId)
            local delta_l = pamt_l > 0 and (cp.close - aep_l) / aep_l * 100 or 0
            local proi_l = delta_l * leverage 
 
            local dir_s = GetPositionDirection(hedge_shortPosId)
            local aep_s = GetPositionEnterPrice(hedge_shortPosId)
            local pamt_s = GetPositionAmount(hedge_shortPosId)
            local delta_s = pamt_s > 0 and (aep_s - cp.close) / aep_s * 100 or 0
            local proi_s = delta_s * leverage
 
            Log('LONG position ROI: '..Round(proi_l, 4)..'%')
            Log('SHORT position ROI: '..Round(proi_s, 4)..'%')

        -- Trend Rules
            local rules = {
                ma_up = ma1 > ma2,
                ma_dn = ma1 < ma2,
                }    

        -- Trend Plots
            Plot(0, 'MA1', ma1, {c=Aqua, w=1})
            Plot(0, 'MA2', ma2, {c=Orange, w=1})
 
        -- not using spread if we have a position
          -- if pamt_l > 0 or pamt_s > 0 then
            --   minSpread = 0
           -- end
 
        -- manage position ids
            if pamt_l == 0 and IsPositionClosed(hedge_longPosId) then
                if IsAnyOrderOpen(hedge_longPosId) then
                    CancelAllOrders(hedge_longPosId)
                else
                    hedge_longPosId = NewGuid()
                    dir_l = GetPositionDirection(hedge_longPosId)
                    aep_l = GetPositionEnterPrice(hedge_longPosId)
                    pamt_l = GetPositionAmount(hedge_longPosId)
                    proi_l = GetPositionROI(hedge_longPosId)
                end
            end
            
            if pamt_s == 0 and IsPositionClosed(hedge_shortPosId) then
                if IsAnyOrderOpen(hedge_shortPosId) then
                    CancelAllOrders(hedge_shortPosId)
                else
                    hedge_shortPosId = NewGuid()
                    dir_s = GetPositionDirection(hedge_shortPosId)
                    aep_s = GetPositionEnterPrice(hedge_shortPosId)
                    pamt_s = GetPositionAmount(hedge_shortPosId)
                    proi_s = GetPositionROI(hedge_shortPosId)
                end
            end
        
        -- get pos id
            local getPositionId = function(isLong)
                return isLong and hedge_longPosId or hedge_shortPosId
            end
 
-- wallet check
    local TMC = TradeMarketContainer(getMarket)
    local MTA = TMC.minimumTradeAmount
    local profitLabel = ProfitLabel()
    if profitLabel == nil then profitLabel = QuoteCurrency() end
    local availBal = testWallet and testBal or WalletAmount(AccountGuid(), profitLabel)
    local getProfitL = GetCurrentProfit(PositionLong)
    local getProfitS = GetCurrentProfit(PositionShort)
    local getProfit = getProfitL + getProfitS
    local usedLong = UsedMargin(getMarket, aep_l, pamt_l, leverage)
    local usedShort = UsedMargin(getMarket,aep_s, pamt_s, leverage)
    --Log('usedLong '..usedLong..' usedShort '..usedShort)
    local botProfit = GetBotProfit()
       
    -- balance warning
        local walletBal = compound and (availBal + botProfit) or availBal
        local workBal = usedLong + usedShort - getProfit
        local budgetBal = maxBudget * walletBal
        local balRatio = budgetBal > 0 and workBal / budgetBal or 0
        --Log('walletBal '..walletBal)
        if balRatio > 0.5 and balRatio < 0.8 then LogWarning('Working balance is > 50% of Budget!!!') end
        if balRatio > 0.8 then LogWarning('Working balance is > 80% of Budget!!!') end
        Log('Balance Monitor '..exchangeCode..' -> Budget Balance: '..Round(budgetBal, 5)..' '..profitLabel..' | Working Balance: '..Round(workBal, 5)..' '..profitLabel..' | Ratio: '..Round(balRatio, 3))
 
        local BRCounter = Load('BRCounter', 0)
        if balRatio > BRCounter then Save('BRCounter', balRatio) end
        
-- dynamics
    --max position
        if profitLabel == 'USD' or profitLabel == 'USDT' or profitLabel == 'BUSD' then
            maxMax = walletBal * maxBudget * maxOpen / cp.close 
 
        else
            maxMax = walletBal * maxBudget * maxOpen * cp.close / contVal 
        
        end
 
        local maxCheck = autoMax and (maxMax * leverage)
        local maxValue = autoMax and (maxCheck > maxSizeM) and maxCheck or maxSizeM
        local maxSize = autoMax and maxValue or maxSizeM
 
        -- check max open  
            if autoMax then
                if maxCheck > maxSizeM then
                    Log('Dynamic Max Open: '..Round(maxCheck, 5)..' '..AmountLabel())
 
                else        
                    Log('Dynamic Max Open: '..Round(maxCheck, 5)..' but using default value: '..Round(maxSizeM, 5)..' '..AmountLabel())
 
                end            
            end 
    
    -- slot size
        local slotCheck = autoSlot and (maxSize / slotBudget)
        local slotValue = autoSlot and (slotCheck > slotSizeM) and slotCheck or slotSizeM
        local slotSize = autoSlot and slotValue or slotSizeM
        
        if autoSlot then
            if slotCheck > slotSizeM then
                slotSizeL = slotSize
                slotSizeS = slotSize
                Log('Dynamic Slot Size: '..Round(slotSize, 5))
            
            else
                slotSizeL = slotSize
                slotSizeS = slotSize                 
                Log('DSSize: '..Round(slotCheck, 5)..' But using default value: '..Round(slotSizeM, 5))
            
            end
            
        else
            slotSizeL = slotSizeM
            slotSizeS = slotSizeM
        Log('Slot Size Value: '..Round(slotSize, 5))
        end
 
 
 
-- SMM CORE LOGIC HEDGE MODE 
        -- slot function
                local slot = function(isLong, index, amount, spread, cancelDist, canPlace)
                local prefix = isLong and 'L' or 'S'
                local name = prefix .. index
                local cmd = isLong and PlaceBuyOrder or PlaceSellOrder
                local priceBase = isLong
                        and cp.bid
                        or cp.ask
                local spr = Min(averageSpreadPercentage, minSpread) + spread * index
                local posId = getPositionId(isLong)
                local aep = isLong and aep_l or aep_s
 
                -- if we have average entry price
                if aep > 0 then
                    priceBase = isLong
                            and Min(aep, priceBase)
                            or Max(aep, priceBase)
                end
 
                -- get price
                local price = isLong
                        and SubPerc(priceBase, spr)
                        or AddPerc(priceBase, spr)
 
                local oid = Load(name..'oid', '') -- order id
 
                if oid != '' then
                    local order = OrderContainer(oid)
 
                    if order.isOpen then
                        local delta = isLong
                                and Delta(AddPerc(order.price, spr), priceBase)
                                or Delta(priceBase, SubPerc(order.price, spr))
                        
                        if delta >= cancelDist then
                            CancelOrder(oid)
                            LogWarning('Delta cancelled '..name)
                        elseif not canPlace then
                            CancelOrder(oid)
                            LogWarning('Not allowed right now '..name)
                        end
                    else
                        oid = ''
                    end
                else
                    if canPlace then
                        SetFee(Abs(MakersFee())*-1)
                        oid = cmd(price, amount, {type = MakerOrCancelOrderType, note = name, timeout = 3600, positionId = posId})
                    end
                end
 
                Save(name..'oid', oid)
            end

        -- updated fixed preplaced or trailing take-profit
            local updateTakeProfit = function(isLong, entryPrice, targetRoi, cancelDist)        
            local prefix = isLong and 'Long ' or 'Short '
            local tprefix = tp_type == 'Trailing' and prefix.. 'Trailing ' or prefix.. 'Fixed '
            local name = tprefix .. ' Take-Profit'
            local oid = Load(prefix .. 'tp_oid', '')
            local timer = Load(prefix .. 'tp_timer', 0)
            local posId = getPositionId(isLong)
            local tp_delta = isLong and Delta(entryPrice, cp.bid) or Delta(cp.ask, entryPrice)
 
                if oid != '' then
                    local order = OrderContainer(oid)
 
                    if order.isOpen then
                        local delta = isLong
                                and Delta(order.price, cp.close)
                                or Delta(cp.close, order.price)
                        
                        if delta >= cancelDist then
                            CancelOrder(oid)
                            LogWarning('Delta cancelled '..name)
                        end
                    else
                        if order.isCancelled then
                            timer = 0
                        end
                        
                        oid = ''
                    end
                else
                    if preplacedTP and tp_type == 'Fixed' then --preplace
                        if isLong and pamt_l > 0 then
                            local exitL = AddPerc(aep_l, takeProfitL)
                            SetFee(tpOrderType == MarketOrderType and TakersFee() or Abs(MakersFee())*-1)
                            oid = PlaceExitPositionOrder({price= exitL, type = tpOrderType, note = 'Pre-Placed '..name, timeout = 600, positionId = hedge_longPosId})
                        end
 
                        if not isLong and pamt_s > 0 then
                            local exitS = SubPerc(aep_s, takeProfitS)
                            SetFee(tpOrderType == MarketOrderType and TakersFee() or Abs(MakersFee())*-1)
                            oid = PlaceExitPositionOrder({price= exitS, type = tpOrderType, note = 'Pre-Placed '..name, timeout = 600, positionId = hedge_shortPosId})
                        end
                     elseif not preplacedTP and tp_type == 'Fixed' then 
                     local trigger = false
                     --place on trigger
                        trigger = tp_delta >= targetRoi
                    else
                        trigger = TrailingStopLoss(trail_dist, posId) and GetPositionROI(posId) / Leverage() > trail_min_profit
                    end
                   --[[if tp_type == 'Trailing' then --we trail with trigger
                      local preplacedTP = false
                        trigger = TrailingStopLoss(trail_dist, posId) and GetPositionROI(posId) / Leverage() > trail_min_profit
                        end]]
                
                    if trigger and Time() >= timer then
                        oid = PlaceExitPositionOrder({type = tpOrderType, note = name, timeout = 3600, positionId = posId})
                        timer = Time() + 60 -- 1min
                    end
                end
 
                Save(prefix .. 'tp_oid', oid)
                Save(prefix .. 'tp_timer', timer)
            end
 --[[        -- updated fixed preplaced or trailing take-profit
            local updateTakeProfit = function(isLong, entryPrice, targetRoi, cancelDist)        
            local prefix = isLong and 'Long ' or 'Short '
            local tprefix = tp_type == 'Trailing' and prefix.. 'Trailing ' or prefix.. 'Fixed '
            local name = tprefix .. ' Take-Profit'
            local oid = Load(prefix .. 'tp_oid', '')
            local timer = Load(prefix .. 'tp_timer', 0)
            local posId = getPositionId(isLong)
            local tp_delta = isLong and Delta(entryPrice, cp.bid) or Delta(cp.ask, entryPrice)
 
                if oid != '' then
                    local order = OrderContainer(oid)
 
                    if order.isOpen then
                        local delta = isLong
                                and Delta(order.price, cp.close)
                                or Delta(cp.close, order.price)
                        
                        if delta >= cancelDist then
                            CancelOrder(oid)
                            LogWarning('Delta cancelled '..name)
                        end
                    else
                        if order.isCancelled then
                            timer = 0
                        end
                        
                        oid = ''
                    end
                else
                if tp_type == 'Fixed' and preplacedTP then --frog pre place logic
                        if isLong and pamt_l > 0 then
                            local exitL = AddPerc(aep_l, takeProfitL)
                            SetFee(tpOrderType == MarketOrderType and TakersFee() or Abs(MakersFee())*-1)
                            oid = PlaceExitPositionOrder({price= exitL, type = tpOrderType, note = 'Pre-Placed '..name, timeout = 600, positionId = hedge_longPosId})
                        end
 
                        if not isLong and pamt_s > 0 then
                            local exitS = SubPerc(aep_s, takeProfitS)
                            SetFee(tpOrderType == MarketOrderType and TakersFee() or Abs(MakersFee())*-1)
                            oid = PlaceExitPositionOrder({price= exitS, type = tpOrderType, note = 'Pre-Placed '..name, timeout = 600, positionId = hedge_shortPosId})
                        end
                
                    if not preplacedTP then --do fixed vs TSSL logic
                       local trigger = false
 
                    if tp_type == 'Fixed' then
                        trigger = tp_delta >= targetRoi
                    else
                        trigger = TrailingStopLoss(trail_dist, posId) and GetPositionROI(posId) / Leverage() > trail_min_profit
                    end
                    if trigger and Time() >= timer then
                        oid = PlaceExitPositionOrder({type = tpOrderType, note = name, timeout = 3600, positionId = posId})
                        timer = Time() + 60 -- 1min
                    end
                end
 
                Save(prefix .. 'tp_oid', oid)
                Save(prefix .. 'tp_timer', timer)
            end
 ]]
 
        -- update position size
            local updatePositionManagement = function(isLong, currentSize, sizeLimit, cancelDist)
                local prefix = isLong and 'Long' or 'Short'
                local name = prefix .. ' Size Reduction'
                local oid = Load(prefix .. 'pos_oid', '')
                local posId = getPositionId(isLong)
                local amount = SubPerc(currentSize, 100 - reduceSize) -- take X% of position
                local price = isLong
                        and cp.ask
                        or cp.bid
                local cmd = isLong
                        and PlaceSellOrder
                        or PlaceBuyOrder
                local timer = Load(prefix .. 'pos_timer', Time())
 
                if oid != '' then
                    local order = OrderContainer(oid)
 
                    if order.isOpen then
                        local delta = isLong
                                and Delta(order.price, cp.close)
                                or Delta(cp.close, order.price)
                        
                        if delta >= cancelDist then
                            CancelOrder(oid)
                            LogWarning('Delta cancelled '..name)
                        end
                    else
                        oid = ''
                    end
                else
                    if currentSize > sizeLimit and not noReduce and Time() >= timer then
                        SetFee(reduceOrderType == MarketOrderType and TakersFee() or Abs(MakersFee())*-1)
                        oid = cmd(price, amount, {type = reduceOrderType, note = name, timeout = 6000, positionId = posId})
                        timer = Time() + 60 -- 1min
                        sizeRed = 1
                        Save('SRCounter', SRCounter + sizeRed)   
                    end
                end
 
                Save(prefix .. 'pos_oid', oid)
                Save(prefix .. 'pos_timer', timer)
            end
 
 
        -- da logica
 
            -- take profit
            updateTakeProfit(true, aep_l, takeProfitL, slotCancel)
            updateTakeProfit(false, aep_s, takeProfitS, slotCancel)
 
            -- risk management
            updatePositionManagement(true, pamt_l, maxSize, slotCancel)
            updatePositionManagement(false, pamt_s, maxSize, slotCancel)
 
 
            -- update slots
            for i = 1, slotCount do
                slot(true, i, slotSizeL, slotSpread, slotCancel, (okLong and rules.ma_up)) -- long slot
            end
 
            for i = 1, slotCount do
                slot(false, i, slotSizeS, slotSpread, slotCancel, (okShort and rules.ma_dn)) -- short slot
            end
 
            if aep_l > 0 then
                local posId = getPositionId(true)
                Plot(0, 'AvgEP Long', aep_l, {c=Green, id=posId, w=2})
            end
 
            if aep_s > 0 then
                local posId = getPositionId(false)
                Plot(0, 'AvgEP Short', aep_s, {c=Red, id=posId, w=2})
            end
 
            
 
            Save('hedge_longPosId', hedge_longPosId)
            Save('hedge_shortPosId', hedge_shortPosId)
 
-- WTF
    if wtfStop then
        local longNull = pamt_l == 0
        local shortNull = pamt_s == 0
        if longNull and shortNull then
            DeactivateBot('Deactivate on No Position is active', true)
 
        else
            LogWarning('Will deactivate on No Position, waiting...maybe next second, maybe never :)')
 
        end
    end
 
    if wtfBal then
        if workBal > budgetBal then
            DeactivateBot('Over Budget', true)
        end
    end
 
    if wtfAmount then
        if pamt_l > maxSize or pamt_s > maxSize then
            DeactivateBot('Over Size', true)
        end
    end
 
    if wtfRatio then 
        if balRatio > wtfRatioV then 
            DeactivateBot('Bal Ratio is over '..wtfRatioV, true)
        end
    end
    
--[[ PlotExposure    
    local lineLong = IfElse(pamt_l > 0, pamt_l, 0)
    local lineShort = IfElse(pamt_s > 0, -pamt_s, 0)
    Plot(1, 'Longs', lineLong, {c=Green, s=Step})
    Plot(1, 'Max Longs', maxSize, {c=White, s=Step})
    Plot(1, 'Shorts', lineShort, {c=Red, s=Step})
    Plot(1, 'Max Shorts', -maxSize, {c=White, s=Step})
    ChartSetOptions(1, 'Exposure')
 
   -- Plot(2, 'Budget Balance', (walletBal * maxBudget), {c=White, s=Step})
   -- Plot(2, 'WorkBal', workBal, {c=Red, s=Step})
   -- ChartSetOptions(2, 'Balance Monitor')]]
 
Log('Size Reduction: '..SRCounter..' times')
if not okLong then
    LogWarning('Bot is not allowed to open LONG')
end
 
if not okShort then
    LogWarning('Bot is not allowed to open SHORT')
end

CC_ReportMaxRiskPoint()
 
-- custom reports
    Finalize(function()  
        CustomReport('Final Wallet Balance', Round(walletBal, 5)..' '..profitLabel)
        CustomReport('Size Reduction', SRCounter..' times')
        CustomReport('Highest Balance Ratio', Round(100 * BRCounter, 2)..'%')
        if testWallet then
            local profitPercent = Round(PercentageChange(testBal, walletBal), 2) 
            CustomReport('Profit %: ', profitPercent..'%')
            CustomReport('Profit to Highest Bal. Ratio', Round(profitPercent / (100 * BRCounter), 2))
        end
    end)
 
 
Log(' ')