--[[
 
    -- position info
        GetPos( isLong ) : returns the position container (long if true, short if false)
        PosAEP( isLong ) : returns position average entry price
        PosROI( isLong ) : returns position ROI %
        PosAmount( isLong ) : returns position amount
        PosProfit( isLong ) : returns position profit
 
    -- bots inner memory
        SaveValue( key, value ) : save and store a value, similarly to Save() command, but it will be stored inside the bot itself
        LoadValue( key, default ) : returns saved value from bots memory storage or default
 
    -- modules
        AddModule( mod_obj, priority ) : add module object into bot. priority determines what is executed first. priority 1 executes before priority 2 etc
        GetModule( mod_name) : get module by name
 
    -- signals
        SetSignalMode( signalMode ) : sets the bots current signal mode (see <code>signalModules</code>)
        AddSignal( signal ) : adds a signal from a module to the bot. must be called inside modules <code>calculate</code> function
        GetSignal( module_name ) : gets the signal set by another module. NOTE: the module signal is fetched from must have executed before this is called, otherwise signal is SignalNone
 
    -- trading
        IsLongEnabled() : true/false if longs are enabled
        IsShortEnabled() : true/false if shorts are enabled
        EnableLongs() : enable long entries
        EnableShorts() : enable short entries
        DisableLongs() : disable long entries
        DisableShorts() : disable short entries
        GoLong { price, amount, type, note, timeout, custom_index } : place long or buy order
        GoShort { price, amount, type, note, timeout, custom_index } : place short or sell order
        ExitLong { price, amount, type, note, timeout, custom_index } : place exit long or sell order
        ExitShort { price, amount, type, note, timeout, custom_index } : place exit short or buy order
        
    -- orders
        GetOrders( isLong, isExit ) : gets long/short entry/exit orders
        Cancel( index, isLong, isExit ) : cancels an open order based on index and parameters
        CancelAllEntries( isLong ) : cancel all entry orders for long/short side
        CancelAllExits( isLong ) : cancel all exit orders for long/short side
        CancelAllPosition( isLong ) : cancel all entries and exits for long/short side
 
    -- plotting and logging
        PlotLine( chartId, name, value, options/color ) : same as Plot() but will also log the info in live bots
        Print(msg [, color]) : prints a log message, also takes currently running module into account and uses its name in log messages (instead of SSv3) 
 
    -- main
        Update() : runs the bots inner workings
        UpdateModules() : updates all modules, this is called in bot.Update
        SaveBot() : saves bots information
 
    -- customizable event functions
        OnInit(bot_obj) : is called when bot initializes and starts running, input is the bot itself

]]


-- Author: pshai
 
 
----- DO NOT REMOVE!! -----
HideOrderSettings()
HideTradeAmountSettings()
EnableHighSpeedUpdates(true)
---------------------------
 
local inLabs = Input('In Labs?', false, 'Whether or not we are in labs. If true, the bot loads market data based on the market selection input. If false, bot uses the main market set in the main settings.')
local allMarkets = {"BTC","ETH","ADA","BNB","DOT","EOS","ETC","LINK","LTC","TRX","XLM","XMR","XRP","XTZ","BCH","ALGO","ALPHA","ATOM","AVAX","AXS","BAL","BAND","BAT","BEL","BLZ","COMP","CRV","CVC","DASH","DEFI","EGLD","ENJ","FLM","FTM","HNT","ICX","IOST","IOTA","KAVA","KNC","KSM","LRC","MATIC","MKR","NEAR","NEO","OCEAN","OMG","ONT","QTUM","REN","RLC","RSR","RUNE","SNX","SOL","SRM","STORJ","SUSHI","SXP","TOMO","TRB","VET","WAVES","YFI","ZEC","ZIL","ZRX","ZEN","SKL","GRT","1INCH","CTK","CHZ","SAND","ANKR","DOGE","LIT","UNFI","REEF","RVN","SFP","XEM","COTI","CHR","MANA","HBAR","ALICE","ONE","LINA","STMX","DENT","CELR","HOT","MTL","OGN","FIL","AAVE","THETA","UNI"}
local selectMarket = InputOptions('Market', allMarkets[1], allMarkets)
 
 
local logModes = {
    default = 'Default',
    onTrades = 'On Trades Only'
}
local logMode = InputOptions('Log Mode', logModes.default, logModes)
 
local market = inLabs and CreateMarket({baseCurrency = selectMarket}) or PriceMarket()
 
--===================================================================
--== Enumerations
 
    local signalModes = {
        unanimous = "Unanimous",
        consensus = "Consensus",
        weightedConsensus = "Weighted Consensus"
    }
 
 
 
--===================================================================
--== The Beast itself
    function getBot(name, market)
        
        -------------------------------------------------------------------------------
        -- private variables #1
            market = market or PriceMarket()
            local base_chart_id = market != PriceMarket() and 1 or 0
            local can_run = Load(market..name..':cr', false)
            local init = Load(market..name..':init', true)
            local long_pid = Load(market..name..':lpid', NewGuid())
            local short_pid = Load(market..name..':spid', NewGuid())
            local long_pos = PositionContainer(long_pid)
            local short_pos = PositionContainer(short_pid)
            local long_eids = Load(market..name..':leids', {}) -- long entry order ids
            local short_eids = Load(market..name..':seids', {}) -- short entry order ids
            local long_xids = Load(market..name..':lxids', {}) -- long exit order ids
            local short_xids = Load(market..name..':sxids', {}) -- short exit order ids
            local allow_longs = Load(market..name..':al', false)
            local allow_shorts = Load(market..name..':as', false)
            local signal_mode = Load(market..name..':sm', signalModes.unanimous)
        -------------------------------------------------------------------------------
        -- private variables #2
            local isBT = Load(market..name..':ibt', false)
            local plot_msgs = {} -- when we are live, we log plot info
            local cp = CurrentPrice(market)
            local mktType = MarketType(market)
            local is_spot = mktType == SpotTrading
            local goLong_cmd = is_spot and PlaceBuyOrder or PlaceGoLongOrder
            local goShort_cmd = is_spot and PlaceSellOrder or PlaceGoShortOrder
            local exLong_cmd = is_spot and PlaceSellOrder or PlaceExitLongOrder
            local exShort_cmd = is_spot and PlaceBuyOrder or PlaceExitShortOrder
            local modules = {}
            local current_module, current_signalWeight, current_interval
            local log_queue = {}
            local order_placed = false
 
            if is_spot then
                --short_pos = long_pos
                --short_pid = long_pid
            end
 
            local log = function(msg, color, force)
                local from = current_module == nil and name or current_module.name
                msg = '['..from..']: ' .. msg
 
                if force then
                    Log(msg, color or '')
                else
                    log_queue = ArrayAdd(log_queue, {msg, color or ''})
                end
            end
 
            local printLogs = function()
                if logMode != logModes.default
                and not order_placed
                then
                    return
                end
 
                local count = Count(log_queue)
 
                if count > 0 then
                    for i = 1, count do
                        local logMsg = log_queue[i]
 
                        Log(logMsg[1], logMsg[2])
                    end
                end
            end
 
 
            if base_chart_id > 0 then
                PlotPrice(base_chart_id, market)
            end
            -------------------------------------------------------------------------------
            -- empty function to mask all output functions of bot unless we can run
                function empty_function() end
 
            -------------------------------------------------------------------------------
            -- the bot object
                local bot_obj = {
                
                -- position information
                    GetPos = empty_function,
                    PosAEP = empty_function,
                    PosROI = empty_function,
                    PosAmount = empty_function,
                    PosProfit = empty_function,
 
                -- memory
                    SaveValue = empty_function,
                    LoadValue = empty_function,
 
                -- modules
                    AddModule = empty_function,
                    GetModule = empty_function,
                    UpdateModules = empty_function,
                    
                -- signals
                    SetSignalMode = empty_function,
                    AddSignal = empty_function,
                    GetSignal = empty_function,
 
                -- trading
                    IsLongEnabled = empty_function,
                    IsShortEnabled = empty_function,
                    EnableLongs = empty_function,
                    EnableShorts = empty_function,
                    DisableLongs = empty_function,
                    DisableShorts = empty_function,
                    GoLong = empty_function,
                    GoShort = empty_function,
                    ExitLong = empty_function,
                    ExitShort = empty_function,
                    Cancel = empty_function,
                    CancelAllEntries = empty_function,
                    CancelAllExits = empty_function,
                    CancelAllPosition = empty_function,
                    
                -- core
                    Update = empty_function,
                    SaveBot = empty_function,
                    Print = empty_function,
 
                -- charting
                    PlotLine = empty_function,
 
                -- overridable "event" functions
                    OnInit = nil,
                    OnOpenOrder = nil,
                    OnFilledOrder = nil,
                    OnPartiallyFilledOrder = nil,
                    OnFailedOrder = nil
                }
        
 
        -------------------------------------------------------------------------------
        -- load wallet info
            local wallet = {base = 0, quote = 0}
 
            if is_spot then
                wallet.base = WalletAmount({coin = BaseCurrency(market)})
                wallet.quote = WalletAmount({coin = QuoteCurrency(market)})
            else
                wallet.base = WalletAmount({coin = UnderlyingAsset(market)})
                wallet.quote = wallet.base
            end
            
        -------------------------------------------------------------------------------
        -- single/multi order mode. if enabled, we only allow 1 open order at a time,
        -- otherwise we use max_open_orders (see below)
            local single_order_mode = false
        
        -------------------------------------------------------------------------------
        -- max open entries/exits allowed (entries and exits do not block each other!)
        -- change this to your liking
            local max_open_orders = 50
 
        -------------------------------------------------------------------------------
        -- short-hand function for: if v then return v else return d end
            local def = |v, d| v or d
 
        -------------------------------------------------------------------------------
        -- colors used for logging
            local color = {
                info = DarkGray,
                blocked = Purple,
                warn = Yellow,
                fail = Red,
                success = Green
            }
 
        -------------------------------------------------------------------------------
        -- words used for logging
            local words = {
                go_long = is_spot and 'BUY' or 'GO LONG',
                go_short = is_spot and 'SELL' or 'GO SHORT',
                exit_long = is_spot and 'SELL-X' or 'EXIT LONG',
                exit_short = is_spot and 'BUY-X' or 'EXIT SHORT',
            }
        
        -------------------------------------------------------------------------------
        -- customizable functions
    --[[
            -------------------------------------------------------------------------------
            -- initialization "event"
                function onInit()
                    -- do initialization. runs only once when bot starts
                end
 
            -------------------------------------------------------------------------------
            -- open order "event"
                function onOpenOrder(order)
                    -- do smth when order is open.
                    -- [order] input is an OrderContainer object
                end
 
            -------------------------------------------------------------------------------
            -- filled order "event"
                function onFilledOrder(order)
                    -- do smth when order is filled.
                    -- [order] input is an OrderContainer object
 
                    log('Order was filled!', color.success)
                end
 
            -------------------------------------------------------------------------------
            -- partially filled order "event"
                function onPartiallyFilledOrder(order, isOpen)
                    -- do smth when order is partially filled.
                    -- [order] input is an OrderContainer object
 
                    local extra = isOpen and ' (order is open)' or ' (order is not open)'
                    log('Order was partially filled.' .. extra, color.info)
                end
 
            -------------------------------------------------------------------------------
            -- cancelled/failed order "event"
                function onFailedOrder(order)
                    -- do smth when order is failed/cancelled.
                    -- [order] input is an OrderContainer object
 
                    log('Order was cancelled!', color.warn)
                end
    ]]
 
        -------------------------------------------------------------------------------
        -- built-in private functions, getters and setters
 
            
            -------------------------------------------------------------------------------
            -- check if we are in backtest or not
            -- will not work properly if high-speed mode is not used!
                function check_is_bt()
                    -- dont check if we can already run
                    if can_run then
                        return
                    end
 
                    local t = Time() -- current time
                    local rt = t - (t % 60) -- get fraction
                    local dt = t - rt -- delta time
                    local dc = Load(name..':btdc', 0) -- delta count
                    local c = Load(name..':btc', 0) -- run count
 
                    if c < 3 then
                        if c > 0 and dt > 0 then
                            can_run = true
                        end
 
                        dc = dc + dt
                        c = c + 1
                    else
                        if dc == 0 then
                            isBT = true
                        end
 
                        can_run = true
                    end
 
                    if can_run then
                        log('(this is ' .. (not isBT and 'not' or '') .. ' a backtest...)', color.info)
                    end
 
                    Save(name..':btdc', dc)
                    Save(name..':btc', c)
 
                    CustomReport('Is backtest', (isBT and 'true' or 'false'))
                end
 
            -------------------------------------------------------------------------------
            -- custom value-memory parameters
                --local max_mem_length = 10 -- maximum sets of save-values
                local max_mem_arr_length = 5000 -- maximum length of a single set
                local mem = Load(market..name..'mem', {})
 
            -------------------------------------------------------------------------------
            -- custom value-memory functions
                function getKey(key)
                    return name..':'..key
                end
 
                function load(key, default_value)
                    if default_value == nil then
                        log('Default value for load must be defined. (key = '..key..')', color.fail)
                        return nil
                    end
 
                    key = getKey(key)
 
                    if mem[key] == nil then
                        log('LoadValue: key "'..key..'" not found, default value used')
                        mem[key] = default_value
                    end
 
                    return mem[key]
                end
 
                function save(key, value)
                    if value == nil then
                        log('Value for save must be defined. (key = '..key..')', color.fail)
                        return
                    end
 
                    key = getKey(key)
 
                    mem[key] = value
                end
 
 
 
            -------------------------------------------------------------------------------
            -- modules
                function addModule(module, priority)
                    if not module.name then
                        log('addModule: Module missing name field', color.fail)
                        return
                    end
 
                    if not module.calculate then
                        log('addModule: Module missing calculate function', color.fail)
                        return
                    end
 
                    if signal_mode == signalModes.weightedConsensus and not module.signalWeight then
                        log('addIndicator: Module missing signalWeight field (signal mode is '..signal_mode..')', color.fail)
                        return
                    end
 
                    if not priority then
                        priority = 1
                    end
 
                    if not modules[priority] then
                        arr = {}
                    else
                        arr = modules[priority]
                    end
 
                    local name = module.name
 
                    if arr[name] then
                        log('addModule: module already exists with name "'..name..'"', color.fail)
                        return nil
                    end
 
                    arr[name] = module
 
                    modules[priority] = arr
                end
 
                function getModule(name)
                    if not name then
                        log('getModule: cannot get module with "nil"', color.fail)
                        return nil
                    end
 
                    local module
 
                    for i = 1, Count(modules) do
                        local arr = modules[i]
 
                        if arr[name] then
                            module = arr[name]
                            break
                        end
                    end
 
                    if not module then
                        log('getModule: unable to find module with name "'..name..'"', color.fail)
                        return nil
                    end
 
                    return module
                end
 
                function addModuleSignal(signal)
                    if not current_module then
                        log('addModuleSignal: modules not updated', color.fail)
                        return
                    end
 
                    current_module.signal = signal
 
                    if not isBT then
                        log(current_module.name .. ': ' .. signal)
                    else
                        PlotSignalEnum(-2, signal)
                    end
                end
 
                function getModuleSignal(name)
                    local module = getModule(name)
 
                    if not module then
                        return nil
                    end
 
                    if not module.signal then
                        return SignalNone
                    end
 
                    return module.signal
                end
 
                function updateModules(self)
                    if not self then
                        log('updateModules: must be called as a method bot:UpdateModules()', color.fail)
                        return
                    end
 
                    for k,v in pairs(modules) do
 
                        local module_set = modules[k]
 
                        for module in module_set do
                            current_module = module
                            current_signalWeight = module.signalWeight
 
                            if module.enabled and module.calculate then
                                module.calculate(self)
                            end
                        end
                    end
 
                    current_module = nil
                    current_signalWeight = 0
                end
 
                function setSignalMode(newMode)
                    signal_mode = newMode
                end
 
                function getSignalMode()
                    return signal_mode
                end
 
 
            -------------------------------------------------------------------------------
            -- the juice (memory) that keeps this thing going
                function saveBot()
                    if can_run then
                        Save(market..name..':init', false)
                    end
                    Save(market..name..':ibt', isBT)
                    Save(market..name..':cr', can_run)
                    Save(market..name..':lpid', long_pid)
                    Save(market..name..':spid', short_pid)
                    Save(market..name..':leids', long_eids) -- long entry order ids
                    Save(market..name..':seids', short_eids) -- short entry order ids
                    Save(market..name..':lxids', long_xids) -- long exit order ids
                    Save(market..name..':sxids', short_xids) -- short exit order ids
                    Save(market..name..':al', allow_longs)
                    Save(market..name..':as', allow_shorts)
                    Save(market..name..'mem', mem)
                end
            -------------------------------------------------------------------------------
            -- enable/disable longs/shorts
                function isLongEnabled()
                    return allow_longs
                end
 
                function isShortEnabled()
                    return allow_shorts
                end
 
                function enableLongs()
                    allow_longs = true
                end
 
                function disableLongs()
                    allow_longs = false
                end
 
                function enableShorts()
                    allow_shorts = true
                end
 
                function disableShorts()
                    allow_shorts = false
                end
 
            -------------------------------------------------------------------------------
            -- position info
                function getPos( isLong )
                    if isLong then
                        return long_pos
                    end
 
                    return short_pos
                end
 
                function getAEP(isLong)
                    if isLong then
                        return long_pos.enterPrice
                    end
 
                    return short_pos.enterPrice
                end 
 
                function getAmt(isLong)
                    if isLong then
                        return long_pos.amount
                    end
 
                    return short_pos.amount
                end 
 
                function getProfit(isLong)
                    if isLong then
                        return long_pos.profit
                    end
 
                    return short_pos.profit
                end
 
                function getROI(isLong)
                    if isLong then
                        return long_pos.roi
                    end
 
                    return short_pos.roi
                end
 
            -------------------------------------------------------------------------------
            -- when multi-order mode, get index of an empty slot
                function getNewIndex(list, custom_index)
                    if not custom_index then
                        local count = Count(list)
                        
                        for i = 1, max_open_orders do
                            if not list[i] or list[i] == '' then
                                return i
                            end
                        end
                    
                    else
                        if not list[custom_index] or list[custom_index] == '' then
                            return custom_index
                        else
                            log('Order already open at index: ' .. custom_index)
                        end
                    end
 
                    return -1
                end
 
            -------------------------------------------------------------------------------
            -- update a single order by id
                function updateOrder(index, oid)
                    local o = OrderContainer(oid)
                    local postfix = index --GetType(index) == NumberDataType and index or index
 
                    if o.isOpen then
                        if o.isSellOrder then
                            if o.isExitOrder then
                                Plot(base_chart_id, 'Long Exit '..postfix, o.price, {c = Yellow, id = o.orderId})
                            else
                                Plot(base_chart_id, 'Short Entry '..postfix, o.price, {c = Red, id = o.orderId})
                            end
                        elseif o.isBuyOrder then
                            if o.isExitOrder then
                                Plot(base_chart_id, 'Short Exit '..postfix, o.price, {c = Yellow, id = o.orderId})
                            else
                                Plot(base_chart_id, 'Long Entry '..postfix, o.price, {c = Green, id = o.orderId})
                            end
                        end
 
                        
                        if bot_obj.OnOpenOrder then bot_obj.OnOpenOrder(o, index) end
                        
                        if o.executedAmount - o.filledAmount < o.executedAmount then
                            if bot_obj.OnPartiallyFilledOrder then bot_obj.OnPartiallyFilledOrder(o, true, index) end
                        end
                    else
                        if o.executedAmount > o.filledAmount then
                            if bot_obj.OnPartiallyFilledOrder then bot_obj.OnPartiallyFilledOrder(o, false, index) end
                        elseif o.isFilled then
                            if bot_obj.OnFilledOrder then bot_obj.OnFilledOrder(o, index) end
                        elseif o.isCancelled then
                            if bot_obj.OnFailedOrder then bot_obj.OnFailedOrder(o, index) end
                        end
 
                        oid = '' -- id is reset
                    end
 
                    return oid
                end
 
            -------------------------------------------------------------------------------
            -- update order list
                function updateOrderList(list)
                    --local count = Count(list)
                    local ret = {}
 
                    -- k = index
                    -- v = order id
                    for k,v in pairs(list) do
                        -- only update ids that contain an order
                        if v and v != '' then 
                            local id = updateOrder(k, v) -- update order
                            ret[k] = id -- update id
                        end
                    end
 
                    return ret
                end
                
            -------------------------------------------------------------------------------
            -- update positions
                function updatePositions()
                    if long_pos.amount == 0 and long_pos.enterPrice > 0 then
                        CancelAllOrders(long_pid)
 
                        long_pid = NewGuid()
                    end
 
                    if short_pos.amount == 0 and short_pos.enterPrice > 0 then
                        CancelAllOrders(short_pid)
 
                        short_pid = NewGuid()
                    end
                end
 
 
            -------------------------------------------------------------------------------
            -- plot command. adds msg into queue if not a backtest
                function plot(id, name, value, options)
                    -- if we doing backtest, plot the line
                    if isBT then
                        return Plot(base_chart_id + id, name, value, options)
                    end
                    
                    -- if we live, queue a message of the plot info
                    addPlotMsg(id, name, value, options)
                    return Plot(0, 'a', 0)
                end
 
 
            -------------------------------------------------------------------------------
            -- plot position AEP and size
                function plotPositions(bot)
                    local laep = getAEP(true)
                    local lamt = getAmt(true)
 
                    if lamt > 0 then
                        Plot(base_chart_id, 'Long AEP', laep, {c=Cyan, id = long_pid})
                        Plot(base_chart_id+1, 'Long Size', lamt, {c=Cyan, id = long_pid})
                    end
 
                    local saep = getAEP(false)
                    local samt = getAmt(false)
 
                    if samt > 0 then
                        Plot(base_chart_id, 'Short AEP', saep, {c=Purple, id = short_pid})
                        Plot(base_chart_id+1, 'Short Size', samt, {c=Purple, id = short_pid})
                    end
                end
 
            -------------------------------------------------------------------------------
            -- add plot as a message in queue
                function addPlotMsg(id, name, value, options)
                    options = def(options, SkyBlue)
 
                    local parsed_options = Parse(options, StringType)
                    local color, value2
 
                    if Count(parsed_options) > 1 then
                        color = parsed_options[1]
                    else
                        color = parsed_options
                    end
 
                    if GetType(value) == ArrayDataType
                    or GetType(value) == UserDataDataType
                    then
                        value2 = ArrayGet(value, 1)
                    else
                        value2 = value
                    end
 
                    local len = Count(plot_msgs)
                    local index = len + 1
 
                    plot_msgs[index] = {
                        msg = 'chartId: ' .. id .. ', ' ..
                        'name: ' .. name .. ', ' .. 
                        'value: ' .. value2,
                        color = color
                    }
                end
 
            -------------------------------------------------------------------------------
            -- log chart plots if any and if not a backtest
                function plotMsgs()
                    -- skip if backtest
                    if isBT then
                        return
                    end
 
                    -- count of messages in queue
                    local count = Count(plot_msgs)
 
                    -- skip if not any messages
                    if count == 0 then
                        return
                    end
 
                    -- log messages
                    log('---------------------', color.info)
                    for i = 1, count do
                        local item = plot_msgs[i]
                        log(item.msg, item.color)
                    end
                    log('-- Plots as Logs -------------------', color.info)
                end
 
            -------------------------------------------------------------------------------
            -- long entry
                function goLong(params)
                    if not can_run then
                        return
                    end
 
                    if not allow_longs then
                        log('Not allowed to entry long. (bot.allow_longs = false)', color.blocked)
                        return
                    end
 
                    local price = params[1] or params.price
                    local amount = params[2] or params.amount
                    local type = params[3] or params.type
                    local note = params[4] or params.note
                    local timeout = params[5] or params.timeout
                    local custom_index = params[6] or params.custom_index
 
                    local index = getNewIndex(long_eids, custom_index)
 
                    if not single_order_mode and index == -1 then
                        log('Maximum amount of open long entries already in use, skipping entry.', color.fail)
                        return
                    end
 
                    price = def(price, cp.bid)
                    amount = def(amount, TradeAmount())
                    type = def(type, GetOrderType())
                    note = def(note, 'Long Entry')
                    timeout = def(timeout, 600)
 
                    local wallet_ok = false
 
                    if price > 0 then
                        if is_spot then
                            wallet_ok = WalletCheck(AccountGuid(), QuoteCurrency(market), amount * price)
                        else
                            wallet_ok = IsTradeAmountEnough(market, price, amount, false)
                        end
                    else
                        LogWarning('Something wrong with prices; they are not available!')
                        return
                    end
                    
                    if not wallet_ok then
                        log('Not enough assets to ['..words.go_long..'], please check your wallet.', color.fail)
                        return
                    end
 
                    if single_order_mode then
                        if not long_eids[1] or long_eids[1] == '' then
                            long_eids[1] = goLong_cmd(price, amount, {market = market, timeout = timeout, type = type, note = note, positionId = long_pid})
 
                            log('['..words.go_long..'] placed: price: ' .. price .. ', amount: ' .. amount .. ', note: "'..note..'".', color.info)
 
                            order_placed = true
 
                            return 1
                        else
                            log('['..words.go_long..'] order already open, skipping entry...', color.info)
                        end
                    else
                        long_eids[index] = goLong_cmd(price, amount, {market = market, timeout = timeout, type = type, note = note, positionId = long_pid})
 
                        log('['..words.go_long..'] placed: price: ' .. price .. ', amount: ' .. amount .. ', note: "'..note..'".', color.info)
 
                        order_placed = true
 
                        return 1
                    end
                end
 
            -------------------------------------------------------------------------------
            -- long exit
                function exitLong(params)
                    if not can_run then
                        return
                    end
 
                    local price = params[1] or params.price
                    local amount = params[2] or params.amount
                    local type = params[3] or params.type
                    local note = params[4] or params.note
                    local timeout = params[5] or params.timeout
                    local custom_index = params[6] or params.custom_index
 
                    -- get slot index for empty slot, if any (-1 if not any)
                    local index = getNewIndex(long_xids, custom_index)
 
                    if not single_order_mode and index == -1 then
                        log('Maximum amount of open long exits already in use, skipping exit.', color.fail)
                        return
                    end
 
                    price = def(price, cp.ask)
                    amount = def(amount, long_pos.amount) -- defaults to full position size
                    type = def(type, GetOrderType())
                    note = def(note, 'Long Exit')
                    timeout = def(timeout, 600)
 
 
                    -- dont allow exiting more than we have
                    if amount > long_pos.amount then
                        log('['..words.exit_long..'] amount higher than position size, amount adjusted to position size.', color.info)
 
                        amount = long_pos.amount
                    elseif long_pos.amount == 0 then
                        log('Trying to ['..words.exit_long..'] position when no position open, skipping...', color.info)
 
                        return
                    end
 
                    if single_order_mode then
                        if not long_xids[1] or long_xids[1] == '' then
                            long_xids[1] = exLong_cmd(price, amount, {market = market, timeout = timeout, type = type, note = note, positionId = long_pid})
 
                            log('['..words.exit_long..'] placed: price: ' .. price .. ', amount: ' .. amount .. ', note: "'..note..'".', color.info)
                            
                            order_placed = true
                            
                            return 1
                        else
                            log('['..words.exit_long..'] order already open, skipping exit...', color.info)
                        end
                    else
                        long_xids[index] = exLong_cmd(price, amount, {market = market, timeout = timeout, type = type, note = note, positionId = long_pid})
 
                        log('['..words.exit_long..'] placed: price: ' .. price .. ', amount: ' .. amount .. ', note: "'..note..'".', color.info)
 
                        order_placed = true
 
                        return 1
                    end
                end
 
            -------------------------------------------------------------------------------
            -- short entry
                function goShort(params)
                    if not allow_shorts then
                        log('Not allowed to entry short. (bot.allow_shorts = false)', color.blocked)
                        return
                    end 
 
                    local price = params[1] or params.price
                    local amount = params[2] or params.amount
                    local type = params[3] or params.type
                    local note = params[4] or params.note
                    local timeout = params[5] or params.timeout
                    local custom_index = params[6] or params.custom_index
 
                    local index = getNewIndex(short_eids, custom_index)
 
                    if not single_order_mode and index == -1 then
                        log('Maximum amount of open short entries already in use, skipping entry.', color.fail)
                        return
                    end
 
                    price = def(price, cp.ask)
                    amount = def(amount, TradeAmount())
                    type = def(type, GetOrderType())
                    note = def(note, 'Short Entry')
                    timeout = def(timeout, 600)
 
                    local wallet_ok = false
                    
                    if price > 0 then
                        if is_spot then
                            wallet_ok = WalletCheck(AccountGuid(), QuoteCurrency(market), amount * price)
                        else
                            wallet_ok = IsTradeAmountEnough(market, price, amount, false)
                        end
                    else
                        LogWarning('Something wrong with prices; they are not available!')
                        return
                    end
                    
                    if not wallet_ok then
                        log('Not enough assets to ['..words.go_short..'], please check your wallet.', color.fail)
                        return
                    end
 
                    if single_order_mode then
                        if not short_eids[1] or short_eids[1] == '' then
                            short_eids[1] = goShort_cmd(price, amount, {market = market, timeout = timeout, type = type, note = note, positionId = short_pid})
 
                            log('['..words.go_short..'] placed: price: ' .. price .. ', amount: ' .. amount .. ', note: "'..note..'".', color.info)
 
                            order_placed = true
 
                            return 1
                        else
                            log('['..words.go_short..'] order already open, skipping entry....', color.info)
                        end
                    else
                        short_eids[index] = goShort_cmd(price, amount, {market = market, timeout = timeout, type = type, note = note, positionId = short_pid})
 
                        log('['..words.go_short..'] placed: price: ' .. price .. ', amount: ' .. amount .. ', note: "'..note..'".', color.info)
 
                        order_placed = true
 
                        return 1
                    end
                end
 
            -------------------------------------------------------------------------------
            -- short exit
                function exitShort(params)
                    if not can_run then
                        return
                    end
 
                    local price = params[1] or params.price
                    local amount = params[2] or params.amount
                    local type = params[3] or params.type
                    local note = params[4] or params.note
                    local timeout = params[5] or params.timeout
                    local custom_index = params[6] or params.custom_index
 
                    -- get slot index for empty slot, if any (-1 if not any)
                    local index = getNewIndex(short_xids, custom_index)
 
                    if not single_order_mode and index == -1 then
                        log('Maximum amount of open short exits already in use, skipping exit.', color.fail)
                        return
                    end
 
                    price = def(price, cp.ask)
                    amount = def(amount, short_pos.amount) -- defaults to full position size
                    type = def(type, GetOrderType())
                    note = def(note, 'Short Exit')
                    timeout = def(timeout, 600)
 
 
                    -- dont allow exiting more than we have
                    if amount > short_pos.amount then
                        log('['..words.exit_short..'] amount higher than position size, amount adjusted to position size.', color.info)
 
                        amount = short_pos.amount
                    elseif short_pos.amount == 0 then
                        log('Trying to ['..words.exit_short..'] position when no position open, skipping...', color.info)
 
                        return
                    end
 
                    if single_order_mode then
                        if not short_xids[1] or short_xids[1] == '' then
                            short_xids[1] = exShort_cmd(price, amount, {market = market, timeout = timeout, type = type, note = note, positionId = short_pid})
 
                            log('['..words.exit_short..'] placed: price: ' .. price .. ', amount: ' .. amount .. ', note: "'..note..'".', color.info)
 
                            order_placed = true
 
                            return 1
                        else
                            log('['..words.exit_short..'] order already open, skipping exit...', color.info)
                        end
                    else
                        short_xids[index] = exShort_cmd(price, amount, {market = market, timeout = timeout, type = type, note = note, positionId = short_pid})
 
                        log('['..words.exit_short..'] placed: price: ' .. price .. ', amount: ' .. amount .. ', note: "'..note..'".', color.info)
 
                        order_placed = true
 
                        return 1
                    end
                end
 
 
            -------------------------------------------------------------------------------
            -- fetch orders
                function getOrders(isLong, isExit)
                    local list, msg
 
                    if isLong then
                        list = not isExit
                                and long_eids
                                or long_xids
                        msg = 'Long ' .. (not isExit and 'Entries' or 'Exits')
                    else
                        list = not isExit
                                and short_eids
                                or short_xids
                        msg = 'Short ' .. (not isExit and 'Entries' or 'Exits')
                    end
 
                    if not list then
                        log('failed to fetch '..msg, color.fail)
                        return nil
                    end
 
                    return list
                end
 
 
            -------------------------------------------------------------------------------
            -- cancel order
                function cancelOrder(index, isLong, isExit)
                    local list = getOrders(isLong, isExit)
 
                    local id = list[index]
 
                    if id and id != '' then
                        CancelOrder(id)
                    end
                end
 
                function cancelAllEntries(isLong)
                    local list = getOrders(isLong, false)
 
                    if Count(list) == 0 then
                        return
                    end
 
                    for _,id in pairs(list) do
                        if id != '' then
                            CancelOrder(id)
                        end
                    end
                end
 
                function cancelAllExits(isLong)
                    local list = getOrders(isLong, true)
 
                    if Count(list) == 0 then
                        return
                    end
 
                    for _,id in pairs(list) do
                        if id != '' then
                            CancelOrder(id)
                        end
                    end
                end
 
                function cancelAllPosition(isLong)
                    cancelAllEntries(isLong)
                    cancelAllExits(isLong)
                end
 
 
                function isFilled(index, isLong, isExit)
                    local list = getOrders(isLong, isExit)
 
                    local id = list[index]
 
                    if id and id != '' then
                        return IsOrderFilled(id)
                    end
 
                    return true
                end
 
            -------------------------------------------------------------------------------
            -- main run function
                function update(self)
                    if not can_run then
                        -- check if we are in backtest or not
                        check_is_bt()
 
                        -- run initialization
                        if can_run and init then
                            log('Startup complete!', color.success)
 
                            -- fire custom init function
                            if self.OnInit then self.OnInit(self) end
                        else
                            log('Bot is starting, please wait...', color.info)
                            return
                        end
                    end
 
                    -- update positions
                    updatePositions()
 
                    -- update order lists
                    long_eids = updateOrderList(long_eids)
                    short_eids = updateOrderList(short_eids)
                    long_xids = updateOrderList(long_xids)
                    short_xids = updateOrderList(short_xids)
 
                    plotPositions(self)
 
                    -- update modules
                    --if not IsBotPaused() then
                        updateModules(self)
                    --end
                    
                    -- log plot messages
                    plotMsgs()
 
                    -- print log messages
                    printLogs()
 
                    -- set chart options accordingly
                    if isBT and base_chart_id > 0 then
                        ChartSetOptions(0, '', 0.02)
                        ChartSetOptions(1, 'Main', 0.65)
                    else
                        ChartSetOptions(0, 'Main', 0.65)
                    end
                end
 
        -------------------------------------------------------------------------------
        -- set functions if we can run
            bot_obj.GetPos = can_run and getPos or empty_function
            bot_obj.PosAEP = can_run and getAEP or empty_function
            bot_obj.PosROI = can_run and getROI or empty_function
            bot_obj.PosAmount = can_run and getAmt or empty_function
            bot_obj.PosProfit = can_run and getProfit or empty_function
 
            bot_obj.SaveValue = save
            bot_obj.LoadValue = load
 
            bot_obj.AddModule = can_run and addModule or empty_function
            bot_obj.GetModule = can_run and getModule or empty_function
            bot_obj.UpdateModules = can_run and updateModules or empty_function
            bot_obj.SetSignalMode = can_run and setSignalMode or empty_function
 
            bot_obj.AddSignal = can_run and addModuleSignal or empty_function
            bot_obj.GetSignal = can_run and getModuleSignal or empty_function
 
            bot_obj.IsLongEnabled = isLongEnabled
            bot_obj.IsShortEnabled = isShortEnabled
            bot_obj.EnableLongs = enableLongs
            bot_obj.EnableShorts = enableShorts
            bot_obj.DisableLongs = disableLongs
            bot_obj.DisableShorts = disableShorts
            bot_obj.GoLong = can_run and goLong or empty_function
            bot_obj.GoShort = can_run and goShort or empty_function
            bot_obj.ExitLong = can_run and exitLong or empty_function
            bot_obj.ExitShort = can_run and exitShort or empty_function
            bot_obj.GetOrders = can_run and getOrders or empty_function
 
            bot_obj.Cancel = can_run and cancelOrder or empty_function
            bot_obj.CancelAllEntries = can_run and cancelAllEntries or empty_function
            bot_obj.CancelAllExits = can_run and cancelAllExits or empty_function
            bot_obj.CancelAllPosition = can_run and cancelAllPosition or empty_function
 
            bot_obj.Update = update
            bot_obj.PlotLine = can_run and plot or empty_function
            bot_obj.SaveBot = saveBot
            bot_obj.Print = log
            
 
        -------------------------------------------------------------------------------
        -- return bot object
            return bot_obj
    end
--=========================================================================
 
 
 
-------------------------------------------------------------------------------
-- settings
 
    local trade_margin = Input('Trade Margin', 10)
 
 
 
-------------------------------------------------------------------------------
-- modules
 
 
    -------------------------------------------------------------------------------
    -- SuperTrends module
        local sts = {
            enabled = true,
            name = 'STs'
        }
 
        -- helper function
        sts.get = function(st, c)
            local v = ArrayGet(st, 1)
            if v < c then
                return v, 0
            end
            return 0, v
        end
 
        -- module's main function
        sts.calculate = function(bot)
            OptimizedForInterval(
                0,
                function()
                    -- get price
                    local h = HighPrices({market = market})
                    local l = LowPrices({market = market})
                    local c = ClosePrices({market = market})
                    local hl = (h+l) / 2
 
                    -- variables
                    local st, long, short = {}, {}, {}
 
                    -- calculate STs
                    st[1] = CC_SuperTrendExt(h, l, c, hl, 12, 3, true, false, '1')
                    st[2] = CC_SuperTrendExt(h, l, c, hl, 11, 2, true, false, '2')
                    st[3] = CC_SuperTrendExt(h, l, c, hl, 10, 1, true, false, '3')
 
                    -- set STs in arrays and plot
                    for i = 1, 3 do
                        local v = ArrayGet(st[i], 1)
 
                        Plot(0, 'ST'..i, v, White(100-25*i))
 
                        if v < c then
                            long = ArrayUnshift(long, v)
                        elseif v > c then
                            short = ArrayUnshift(short, v)
                        end
                    end
 
                    -- save arrays
                    bot.SaveValue('st_long', long)
                    bot.SaveValue('st_short', short)
                end
            )
        end
 
 
 
    -------------------------------------------------------------------------------
    -- Stoch-RSI module
        local srsi = {
            enabled = true,
            name = 'STOCHRSI'
        }
 
        -- module's main function
        srsi.calculate = function(bot)
            OptimizedForInterval(
                0,
                function()
                    -- prices and indicators
                    local c = ClosePrices({market = market})
                    local rsi = RSI(c, 14)
                    local k = SMA(SSTOCH(rsi, 14), 3)
                    local d = SMA(k, 3)
 
                    -- plots
                    Plot(2, 'K', k, Yellow)
                    Plot(2, 'D', d, Cyan)
                    PlotHorizontalLine(2, 'u', Gray, 80, Dashed)
                    PlotHorizontalLine(2, 'l', Gray, 20, Dashed)
 
                    -- save default result
                    bot.SaveValue('srsi_le', false)
                    bot.SaveValue('srsi_se', false)
 
                    -- short entry -flag
                    if d > 80
                    and CrossUnder(k, d)
                    then
                        bot.SaveValue('srsi_se', true)
                    
                    -- long entry -flag
                    elseif d < 20
                    and CrossOver(k, d)
                    then
                        bot.SaveValue('srsi_le', true)
                    end
                end
            )
        end
 
 
 
    -------------------------------------------------------------------------------
    -- Trader module
        local trader = {
            enabled = true,
            name = 'TRADER'
        }
 
        -- module's main function
        trader.calculate = function(bot)
            -- loads
            local st_long = bot.LoadValue('st_long', {})
            local st_short = bot.LoadValue('st_short', {})
            local le = bot.LoadValue('srsi_le', false)
            local se = bot.LoadValue('srsi_se', false)
            local tp = bot.LoadValue('trader_tp', 0)
            local sl = bot.LoadValue('trader_sl', 0)
            
            -- current price
            local cp = CurrentPrice(market)
 
            -- position info
            local lamt = bot.PosAmount(true)
            local samt = bot.PosAmount(false)
            local nopos = lamt == 0 and samt == 0
                        and tp == 0 and sl == 0
 
            -- leveraged trade amount
            local cv = ContractValue(market)
            local amt = trade_margin / cv * Leverage()
 
            -- no position situations
            if nopos then
                -- long entry
                if #st_long >= 2 and le then
                    -- entry long
                    bot.GoLong {type = MarketOrderType, amount = amt}
 
                    -- set tp and sl values
                    sl = (cp.ask - ArrayGet(Min(st_long), 1)) / cp.ask * 100
                    tp = sl * 1.5
 
                -- short entry
                elseif #st_short >= 2 and se then   
                    -- entry short
                    bot.GoShort {type = MarketOrderType, amount = amt}
 
                    -- set tp and sl values
                    sl = (ArrayGet(Max(st_short), 1) - cp.bid) / cp.bid * 100
                    tp = sl * 1.5
                end
            
            -- open position situations
            else
 
                -- triggers
                local tp_trig = TakeProfit(tp)
                local sl_trig = StopLoss(sl)
                local note
 
                if tp_trig then
                    note = 'TP'
                elseif sl_trig then
                    note = 'SL'
                end
 
                -- if we set a note, we also exit
                if note then
                    if lamt > 0 then
                        bot.ExitLong {type = MarketOrderType, note = note}
                    elseif samt > 0 then
                        bot.ExitShort {type = MarketOrderType, note = note}
                    end
 
                    tp = 0
                    sl = 0
                end
            end
 
            -- save tp and sl
            bot.SaveValue('trader_tp', tp)
            bot.SaveValue('trader_sl', sl)
        end
 
 
    -------------------------------------------------------------------------------
    -- The Bot
 
        -- create bot object
        local theBot = getBot('STSRSI', market)
 
        -- set bot's OnInit function
        theBot.OnInit = function(bot)
            LogWarning('BOT INITIALIZED')
 
            bot.EnableLongs()
            bot.EnableShorts()
        end
 
        -- add modules
        theBot.AddModule(sts)
        theBot.AddModule(srsi)
        theBot.AddModule(trader)
 
        -- update bot
        theBot:Update()
 
        -- save bot
        theBot.SaveBot()