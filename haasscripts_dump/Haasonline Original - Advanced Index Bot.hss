-- [HaasOnline Original] Advanced Index Bot
-- Author: pshai

HideOrderSettings()
HideTradeAmountSettings()
EnableHighSpeedUpdates(true)


-- ===============================================================
-- Inputs

    local baseCoin = Input('Base Coin', 'BTC', 'This defines the main coin which will be used to buy alt-coins defined by Index Table. For example, if this is set to "BTC", all alt-coin indices will be traded on XXX/BTC markets. Also make sure that your indices have such markets on your exchange of choice!')

    local tradeAmount = Input('Base Index Allocation', 0.1, 'This is the total amount of main coin allocated to the bot, defined by the Base Coin input. For example, if our Base Coin is set to BTC, our main coin would be BTC. This value would then represent the TOTAL BTC allocated for this bot and all its alt-coin indices combined.')

    local indexTable = InputTable(
        InputTableOptions('Index Table', 0, 10),
        InputTableColumn('Coin Name', 'ETH', 'XRP', 'ADA'),
        InputTableColumn('Allocated %', 25, 25, 25),
        InputTableColumn('Buy Threshold % (1-4)', 2, 2, 2),
        InputTableColumn('Sell Threshold % (1-4)', 2, 2, 2),
        InputTableColumn('Buy Orders (3,4)', 0, 0, 0),
        InputTableColumn('Sell Orders (3,4)', 0, 0, 0),
        InputTableColumn('SL %', 0, 0, 0),
        InputTableColumn('TSL %', 0, 0, 0)
    )

    local rebalanceType = InputOptions('Rebalance Type', '1. Portfolio', {'1. Portfolio', '2. Individual', '3. Spider', '4. Flash Crash'}, 'The rebalance type defines how the bot keeps up the allocated index values.')
    local rebalanceInterval = InputInterval('Rebalance Interval', 60, 'How often rebalancing occurs. This only affects Portfolio and Individual growth modes.')

    local rbOrderType = InputOrderType('Rebalance Order Type', LimitOrderType, 'Order type used when a rebalance is necessary. This only affects Rebalance Types 1 and 2, as 3 and 4 will use limit orders regardless.')
    local slOrderType = InputOrderType('(Trailing) Stop-Loss Order Type', MarketOrderType, 'Order type used when (trailing) stop-loss triggers.')

    local sellExcessive = Input('Sell excessive balance', false, 'If true, the bot will sell any excessive balance from the wallet. This is only done ONCE after the bot has started.')
    local preserveBase = Input('Preserve Base Index Value', true, 'If true, the bot will preserve the base coin value. This means, that bot will stop buying more coins if the resulting base index value would drop below allocated base index value.')

-- ===============================================================
-- Logger
    local LoggerLevels = {
        ErrorsOnly = 'Errors Only',
        ErrorsAndWarnings = 'Erorrs & Warnings',
        All = 'All'
    }

    local Logger = {
        _level = InputOptions('DEBUG Level',
                LoggerLevels.All,
                LoggerLevels,
                {group = '     DEBUG'}),
        _in = 'Main',
        _prevIn = {},
        _log = Log,
        _warn = LogWarning,
        _error = LogError,
        _showEntries = false,
        _showExits = false
    }

    function Logger:level()
        if Logger._level == LoggerLevels.ErrorsOnly then
            return 0
        elseif Logger._level == LoggerLevels.ErrorsAndWarnings then
            return 1
        elseif Logger._level == LoggerLevels.All then
            return 2
        end

        LogError('Logger level undefined: "' .. Logger._level .. '"')
    end

    function Logger:where()
        local ret = ''
        local prevs = self._prevIn
        if #prevs > 0 then
            for i = 1, #prevs do
                if prevs[i] != '' and #prevs[i] > 0 then
                    ret = ret .. prevs[i] .. '::'
                end
            end
        end
        return ret .. self._in
    end

    function Logger:enter(to)
        if self._showEntries then
            self:log('cd \\' .. to)
        end

        self._prevIn = ArrayAdd(self._prevIn, self._in)
        self._in = to
    end

    function Logger:exit()
        if self._showExits then
            self:log('cd \\..')
        end

        self._in = ArrayLast(self._prevIn)
        self._prevIn = ArrayPop(self._prevIn)
    end

    function Logger:log(msg, color)
        if self:level() >= 2 then
            local _in = Logger:where()
            self._log('[#'.._in..'] '..msg, color or '')
        end
    end

    function Logger:warn(msg)
        if self:level() >= 1 then
            local _in = Logger:where()
            self._warn('['.._in..'] '..msg)
        end
    end

    function Logger:error(msg)
        local _in = Logger:where()
        self._error('['.._in..'] '..msg)
    end


-- ===============================================================
-- Handy functions

    -- deep clone an object
    function clone(original)
        local copy = {}
        for k, v in pairs(original) do
            if GetType(v) == ArrayDataType then
                v = clone(v)
            end
            copy[k] = v
        end
        return copy
    end

    
    -- check and initialize a module
    function IsModuleInitialized(module)
        if module._init then
            Logger:error('Module "' .. module.name .. '" already initialized!')
            return true
        end

        module._init = true

        return false
    end

    
    function PlotOpenOrders(index)
        local getColor = function(slotIndex)
            local colors = {
                Red,
                Orange,
                DarkGray,
                Gray,
                White,
                Green,
                DarkGreen,
                SkyBlue,
                Purple
            }

            return colors[slotIndex % Count(colors)]
        end

        local buys = index.BuyOrders
        local sells = index.SellOrders
        local buyOrders = index.BuyOrderIds
        local sellOrders = index.SellOrderIds

        for i = 1, buys do
            local oid = buyOrders[i]

            if oid and oid != '' then
                local order = OrderContainer(oid)

                --Plot(index.ChartId, 'Buy-'..SubString(oid, 0, 4), order.price, {c = Green, id = SubString(oid, 0, 4)})
                Plot(index.ChartId, 'Buy-'..i, order.price, {c = getColor(i)})
            end
        end

        for i = 1, sells do
            local oid = sellOrders[i]

            if oid and oid != '' then
                local order = OrderContainer(oid)

                --Plot(index.ChartId, 'Sell-'..SubString(oid, 0, 4), order.price, {c = Red, id = SubString(oid, 0, 4)})
                Plot(index.ChartId, 'Sell-'..i, order.price, {c = getColor(i)})
            end
        end
    end

-- ===============================================================
-- Enums

    local TableId = {
        Name = 1,
        Alloc = 2,
        BuyLevel = 3,
        SellLevel = 4,
        BuyOrders = 5,
        SellOrders = 6,
        SlPrc = 7,
        TslPrc = 8
    }


-- ===============================================================
-- Modules

    -- ---------------------------------------------------------------
    -- Containers

        local Config = {name = 'Config'}

        -- Coin Index Manager
        -- Contains and manages all data for coin indices
        local CIM = {name = 'CIM'}

        -- Coin Index
        -- Coin index object
        local CI = {name = 'CI'}

        -- Position & Trading Manager
        -- Handles all position information and order executions
        local PTM = {name = 'PTM'}

        -- Rebalance Method
        -- Calculates index value/worth/target etc and produces buy/sell signals
        local RM = {name = 'RM'}


        -- Grid item
        local GI = {name = 'GI'}

    -- ---------------------------------------------------------------
    -- Initiators

        function Config:init()
            if IsModuleInitialized(self) then
                return -- do nothing
            end


            self.IndexTable = indexTable
        end

        function CIM:init()
            if IsModuleInitialized(self) then
                return -- do nothing
            end


            self.Index = {}
            self.LastRebalance = Load('cim:lb', 0)

            ChartSetOptions(0, Config:getBaseCoin())
        end

        
        -- We do not initialize Coin Index (CI)


        function PTM:init()
            if IsModuleInitialized(self) then
                return -- do nothing
            end
        end


        function RM:init()
            if IsModuleInitialized(self) then
                return -- do nothing
            end

            self.Method = function() DeactivateBot('Developer error: Rebalance method not set!', true) end
        end


    -- ---------------------------------------------------------------
    -- Config -methods

        function Config:checkSettings()
            Logger:enter('Config')

            local isOK = true
            local table = self:getIndexTable()
            local baseCoin = self:getBaseCoin()
            local tradeAmount = self:getTradeAmount()
            

            -- check trade amount
                if self:getTradeAmount() <= 0 then
                    Logger:error('Cannot sustain an index with a trade amount of '..self:getTradeAmount()..'.')
                    isOK = false
                end

            -- check if base coin is defined
                if self:getBaseCoin() == '' then
                    Logger:error('No base coin defined!')
                    isOK = false
                end

            -- check base index wallet
                if not WalletCheck(AccountGuid(), baseCoin, tradeAmount) then
                    --Logger:error('Not enough '..baseCoin..' in wallet!')
                    --isOK = false
                end
                
            -- check for correct allocation percentages
            -- & check if we can distribute trade amount
                local totalAlloc = 0
                for i = 1, #table do
                    local coin = table[i][TableId.Name]
                    local market = CreateMarket('', coin, baseCoin)
                    local cp = CurrentPrice(market)
                    local minimum = MinimumTradeAmount(market)
                    local alloc = Parse(table[i][TableId.Alloc], NumberType)
                    local amount = SubPerc(tradeAmount, 100 - alloc) / cp.close

                    totalAlloc = totalAlloc + alloc

                    if amount < minimum then
                        Logger:error('Cannot trade ' .. coin .. ': Allocated trade amount is too low. (target value: ' .. amount .. ' ' .. baseCoin .. ', minimum: ' .. minimum .. ')')
                        Logger:log('TIP: Allocate more to Base Index amount or adjust allocation percentage for coin.', Cyan)
                        isOK = false
                    end
                end


                if totalAlloc >= 100 and Load('aib:config:wta', true) then
                    Logger:warn('Total allocation is equal or higher than 100%; please fix index table settings.')
                    Logger:log('TIP: Leave some percentages for the base coin as well; allocating 100% of trade amount will make it hard to buy more coins (you can also ignore this warning if this was intentional).', Cyan)

                    Save('aib:config:wta', false)
                end

            Logger:exit()

            return isOK
        end

        function Config:getBaseCoin()
            return baseCoin
        end

        function Config:getIndexTable()
            return self.IndexTable
        end

        function Config:getTradeAmount()
            return tradeAmount
        end

        function Config:isSpiderMode()
            return StringContains(rebalanceType, 'spider', true)
        end

        function Config:isFlashMode()
            return StringContains(rebalanceType, 'flash', true)
        end

        function Config:isIndividualMode()
            return StringContains(rebalanceType, 'individual', true)
        end

        function Config:isPortfolioMode()
            return StringContains(rebalanceType, 'portfolio', true)
        end

        function Config:getRebalanceOrderType()
            return rbOrderType
        end


    -- ---------------------------------------------------------------
    -- Grid Item -methods
        local GridItemType = {
            Empty = 0,
            Buy = 1,
            Sell = 2
        }

        function GI:load(index, i, price, amount)
            local gi = clone(GI)

            gi.Index            = index
            gi.SlotIndex        = i
            gi.Name             = index.CoinName .. '_' .. i
            gi.DefaultType      = i < 0 and GridItemType.Buy or i > 0 and GridItemType.Sell or LogError('GI:load(): invalid slot index')
            gi.CurrentType      = Load('aib:gi:ct:'..gi.Name, gi.DefaultType)
            gi.OrderId          = Load('aib:gi:oid:'..gi.Name, '')
            gi.PositionId       = Load('aib:gi:pid:'..gi.Name, NewGuid())
            gi.Price            = Load('aib:gi:p'..gi.Name, price)
            gi.Amount           = Load('aib:gi:a'..gi.Name, amount)

            local temp = clone(gi)
            temp.Index = nil
            Log(temp)

            return gi
        end

        function GI:update()
            local dt = self.DefaultType
            local ct = self.CurrentType
            local oid = self.OrderId
            local pid = self.PositionId

            -- process fills
            if oid != '' then

                if oid == '-skip' then
                    Logger:log('skipping slot: ' .. self.Name .. ' (not enough assets?)')
                    return
                end

                local order = OrderContainer(oid)

                if order.isOpen then
                    Plot(self.Index.ChartId, self.Name, order.price, Gray)
                else

                    if order.isFilled
                    and order.filledAmount >= order.executedAmount
                    then
                        Logger:log('order filled', Red)

                        if ct != dt then
                            ct = dt
                            Logger:log('CT != DT????', Red)
                            --pid = NewGuid()
                        else
                            if dt == GridItemType.Buy then
                                Logger:log('CT set to counter SELL', Red)
                                ct = GridItemType.Sell
                            elseif dt == GridItemType.Sell then
                                Logger:log('CT set to counter BUY', Red)
                                ct = GridItemType.Buy
                            end
                        end
                    end

                    oid = ''
                end
            end


            if oid == '' then
                local settings = {
                    market = self.Index.Market,
                    type = LimitOrderType,
                    timeout = -1,
                    positionId = pid,
                    note = self.Name
                }

                local buyThres = self.Index.BuyThreshold
                local sellThres = self.Index.SellThreshold
                local price = self.Price

                Logger:log('price: ' .. price, DarkGray)
                Logger:log('buyThres: ' .. buyThres, DarkGray)
                Logger:log('sellThres: ' .. sellThres, DarkGray)

                if ct != dt then
                    Logger:log('place counter order', Purple)
                    local amount = GetPositionAmount(pid)

                    -- counter-order
                    if ct == GridItemType.Buy then
                        local newPrice = SubPerc(price, sellThres)

                        oid = PlaceBuyOrder(
                            newPrice,
                            amount,
                            settings
                        )
                        
                    elseif ct == GridItemType.Sell then
                        local newPrice = AddPerc(price, buyThres)

                        oid = PlaceSellOrder(
                            newPrice,
                            amount,
                            settings
                        )
                    end
                else
                    Logger:log('place initial order', Green)
                    local amount = self.Amount

                    -- initial order
                    if dt == GridItemType.Buy then
                        oid = PlaceBuyOrder(
                            price,
                            amount,
                            settings
                        )
                    elseif dt == GridItemType.Sell then
                        oid = PlaceSellOrder(
                            price,
                            amount,
                            settings
                        )
                    end
                end
            end

            -- update values
            self.PositionId = pid
            self.OrderId = oid
            self.CurrentType = ct
        end

        function GI:save()
            Save('aib:gi:ct:'..self.Name, self.CurrentType)
            Save('aib:gi:oid:'..self.Name, self.OrderId)
            Save('aib:gi:pid:'..self.Name, self.PositionId)
            Save('aib:gi:p'..self.Name, self.Price)
            Save('aib:gi:a'..self.Name, self.Amount)
        end


    -- ---------------------------------------------------------------
    -- Coin Index Manager -methods

        function CIM:load()
            local table = Config:getIndexTable()

            for i = 1, #table do
                local ci = CI:load(table[i], i)

                self.Index[i] = ci
            end
        end

        function CIM:save()
            Save('cim:lb', self.LastRebalance)
        end


        function CIM:updateAll()
            local len = #self.Index
            local doRebalance = false
            local ptm_allowRemoveOrders = false --not (Config:isSpiderMode() or Config:isFlashMode())

            -- rebalance check based on time
            if (Config:isPortfolioMode() or Config:isIndividualMode())
            and self.LastRebalance + rebalanceInterval * 60 <= Time()
            then
                self.LastRebalance = Time()
                doRebalance = true

                Logger:log('Will do rebalance check.', Gold)
            
            elseif (Config:isSpiderMode() or Config:isFlashMode())
            then
                doRebalance = true
            end

            -- da loop
            for i = 1, len do
                local ci = self.Index[i]

                Logger:enter(ci.CoinName)

                -- update order lists
                if (Config:isPortfolioMode() or Config:isIndividualMode())
                or ci.IsRelocating
                then
                    PTM:updateOrders(
                        ci, 
                        false,
                        ptm_allowRemoveOrders
                    )
                end

                -- update index info
                ci:update()

                -- rebalance method check
                if doRebalance
                and ci:canRebalance()
                then
                    RM:check(ci)
                else
                    Logger:log('Index check was skipped.')
                end

                if not ci.IsExcluded
                and (ci.StopLossActive
                or ci.TrailingStopLossActive) then
                    PTM:stopAndSell(ci)
                end

                ci:save()

                PlotPrice(i, ci.Market)
                ChartSetOptions(i, ci.CoinName)

                Logger:exit()
            end

            self:save()
        end

    -- ---------------------------------------------------------------
    -- Coin Index -methods

        function CI:load(tableItem, i)
            local name                  = Parse(tableItem[TableId.Name],       StringType)
            local alloc                 = Parse(tableItem[TableId.Alloc],      NumberType)
            local buy                   = Parse(tableItem[TableId.BuyLevel],   NumberType)
            local sell                  = Parse(tableItem[TableId.SellLevel],  NumberType)
            local buys                  = Parse(tableItem[TableId.BuyOrders],  NumberType)
            local sells                 = Parse(tableItem[TableId.SellOrders], NumberType)
            local sl                    = Parse(tableItem[TableId.SlPrc],      NumberType)
            local tsl                   = Parse(tableItem[TableId.TslPrc],     NumberType)

            local ci                    = clone(CI)

            ci.ChartId                  = i
            ci.CoinName                 = name
            ci.AllocatedPrc             = alloc
            ci.BuyThreshold             = buy
            ci.SellThreshold            = sell
            ci.BuyOrders                = buys
            ci.SellOrders               = sells
            ci.StopLossPrc              = sl
            ci.TrailingStopLossPrc      = tsl

            ci.Market                   = CreateMarket('', name, Config:getBaseCoin())
            ci.ShouldInit               = Load(ci.Market .. ':si', true)
            ci.LastUsedPrice            = Load(ci.Market .. ':lup', 0)
            ci.PositionId               = Load(ci.Market .. ':pid', NewGuid())
            ci.PositionInfo             = PositionContainer(ci.PositionId)
            ci.BuyOrderIds              = Load(ci.Market .. ':bos', {})
            ci.SellOrderIds             = Load(ci.Market .. ':sos', {})
            ci.BuyOrderId               = Load(ci.Market .. ':bo', '')
            ci.SellOrderId              = Load(ci.Market .. ':so', '')
            ci.StopLossActive           = Load(ci.Market .. ':sla', false)
            ci.TrailingStopLossActive   = Load(ci.Market .. ':tsla', false)
            ci.IsExcluded               = Load(ci.Market .. ':ie', false)
            ci.IsRelocating             = Load(ci.Market .. ':ir', false) -- whether or not we just placed asset relocation order. this is reset when the order fills or fails
            ci.StartPrice               = Load(ci.Market .. ':sp', 0)
            ci.BasePrice                = Load(ci.Market .. ':bp', 0)

            ci.BuyTarget                = 0 -- price value
            ci.SellTarget               = 0 -- price value
            ci.AllocatedAmount          = 0 -- base coin amount
            ci.TargetAmount             = 0 -- base coin amount
            ci.RebalanceSignal          = SignalNone -- this signal should be ignored if index is already relocating assets
            
            --ci.InWallet = BalanceAmount(AccountGuid(), ci.CoinName, ci.Market)
            ci.InWallet                 = BalanceAmount(AccountGuid(), ci.CoinName)
            ci.InWalletBase             = 0
            ci.InVirtualWalletBase      = 0 -- calculated using position amount and price


            -- if wallet amount less than minimum trade amount, ignore what's in the wallet?



            return ci
        end

        function CI:save()
            local id = self.Market

            Save(id .. ':si',   false)
            Save(id .. ':lup',  self.LastUsedPrice)
            Save(id .. ':pid',  self.PositionId)
            Save(id .. ':bos',  self.BuyOrderIds)
            Save(id .. ':sos',  self.SellOrderIds)
            Save(id .. ':bo',   self.BuyOrderId)
            Save(id .. ':so',   self.SellOrderId)
            Save(id .. ':sla',  self.StopLossActive)
            Save(id .. ':tsla', self.TrailingStopLossActive)
            Save(id .. ':ie',   self.IsExcluded)
            Save(id .. ':ir',   self.IsRelocating)
            Save(id .. ':sp',   self.StartPrice)
            Save(id .. ':bp',   self.BasePrice)
        end


        function CI:canRebalance()
            return not (self.ShouldInit
                or self.StopLossActive
                or self.TrailingStopLossActive
                or self.IsExcluded
                or self.IsRelocating)
        end


        function CI:update()
            
            if self.IsExcluded then
                self.StopLossActive = false
                self.TrailingStopLossActive = false
                return
            end

            local market = self.Market
            local cp = CurrentPrice(market)

            -- setup values
            self.AllocatedAmount = self.PositionInfo.amount
            self.InWalletBase = self.InWallet * cp.close
            self.InVirtualWalletBase = self.AllocatedAmount * cp.close
            self.TargetAmount = SubPerc(tradeAmount, 100 - self.AllocatedPrc) / cp.close

            --Logger:log('Trade Amount: ' .. tradeAmount .. ' ' .. Config:getBaseCoin())
            --Logger:log('Allocated %: ' .. self.AllocatedPrc .. ' %')
            --Logger:log('Target Amount: ' .. self.TargetAmount .. ' ' .. self.CoinName)

            if self.ShouldInit then
                Logger:log('Init index')

                -- record prices
                self.StartPrice = cp.close
                self.BasePrice = cp.close

                if self.InWallet > 0 then
                    Logger:log('Has coins in wallet, create position')

                    local minimum = MinimumTradeAmount(self.Market, cp.ask)
                    local amt = self.TargetAmount
                    local shouldBuy = false
                    local shouldSell = false

                    if sellExcessive or self.InWallet < self.TargetAmount then
                        amt = self.InWallet
                    end

                    if (self.TargetAmount - amt) > minimum then
                        shouldBuy = true
                    
                    elseif sellExcessive and (amt - self.TargetAmount) > minimum then
                        shouldSell = true
                    end

                    CreatePosition(PositionBought, cp.close, amt, self.Market, -1, self.PositionId)

                    self.AllocatedAmount = amt
                    self.LastUsedPrice = cp.close

                    if Config:isFlashMode() then
                        shouldBuy = false
                        shouldSell = false
                    end

                    -- should buy more
                    if shouldBuy then
                        local allocAmt = self.AllocatedAmount
                        local targetAmt = self.TargetAmount
                        local diff = targetAmt - allocAmt

                        PTM:buy(self, diff, MarketOrderType)


                    -- should sell excess
                    elseif shouldSell then
                        local allocAmt = self.AllocatedAmount
                        local targetAmt = self.TargetAmount
                        local diff = allocAmt - targetAmt

                        PTM:sell(self, diff, MarketOrderType)

                    end
                
                -- initial buy
                elseif not Config:isFlashMode() then
                    Logger:log('Has no coins in wallet; making a buy order')

                    local targetAmt = self.TargetAmount
                    PTM:buy(self, targetAmt, MarketOrderType)
                end
            else

                local sl = StopLoss(self.StopLossPrc, self.PositionId)
                local tsl = TrailingStopLoss(self.TrailingStopLossPrc, self.PositionId)

                if sl then
                    Logger:warn('Stop-Loss activated')

                    self.StopLossActive = true
                end

                if tsl then
                    Logger:warn('Trailing Stop-Loss activated')

                    self.TrailingStopLossActive = true
                end

            end

        end

    
    -- ---------------------------------------------------------------
    -- Position & Trading Manager -methods

        function PTM:load()
            
        end

        function PTM:buy(coinIndex, amount, type)
            local cp = CurrentPrice(coinIndex.Market)
            amount = ParseTradeAmount(coinIndex.Market, cp.close, amount)

            Logger:log('Trying to execute BUY order')

            if IsTradeAmountEnough(coinIndex.Market, cp.close, amount) then
                local oid = PlaceBuyOrder(cp.close, amount, coinIndex.Market, type, 'Rebalance Buy', coinIndex.PositionId)
                
                coinIndex.LastUsedPrice = cp.close
                coinIndex.IsRelocating = true

                -- add order id to list
                --coinIndex.BuyOrderIds = ArrayAdd(coinIndex.BuyOrderIds, oid)
                coinIndex.BuyOrderId = oid
            else
                Logger:warn('Skipping rebalance BUY; trade amount is not enough: ' .. amount)
            end
        end

        function PTM:sell(coinIndex, amount, type)
            local cp = CurrentPrice(coinIndex.Market)
            amount = ParseTradeAmount(coinIndex.Market, cp.close, amount)

            Logger:log('Trying to execute SELL order')

            if IsTradeAmountEnough(coinIndex.Market, cp.close, amount) then
                local oid = PlaceSellOrder(cp.close, amount, coinIndex.Market, type, 'Rebalance Sell', coinIndex.PositionId)

                coinIndex.LastUsedPrice = cp.close
                coinIndex.IsRelocating = true
                
                -- add order id to list
                --coinIndex.SellOrderIds = ArrayAdd(coinIndex.SellOrderIds, oid)
                coinIndex.SellOrderId = oid
            else
                Logger:warn('Skipping rebalance SELL; trade amount is not enough: ' .. amount)
            end
        end

        function PTM:stopAndSell(coinIndex)
            local cp = CurrentPrice(coinIndex.Market)
            local amount = coinIndex.PositionInfo.amount
            local fba, fbs

            if not coinIndex.IsRelocating then
                fba, fbs = self:updateOrders(coinIndex, true)

                if (fba and fba > 0) or (fbs and fbs > 0) then
                    -- buy and/or sell orders were filled when cancelled,
                    -- but we do not know if these amounts are updated in
                    -- the position yet.
                    -- skipping one update will make sure we are up-to-date.
                    coinIndex.IsRelocating = true
                    return
                end
            end

            Logger:log('Trying to execute TSL/SL SELL order')

            if amount == 0 or IsPositionClosed(coinIndex.PositionId) then
                Logger:log('Index position already closed.')
                coinIndex.IsExcluded = true

                return
            end

            if IsTradeAmountEnough(coinIndex.Market, cp.close, amount) then
                local oid = PlaceSellOrder(cp.close, amount, coinIndex.Market, slOrderType, 'SL/TSL Sell', coinIndex.PositionId)

                coinIndex.IsRelocating = true
                
                -- add order id to list
                --coinIndex.SellOrderIds = ArrayAdd(coinIndex.SellOrderIds, oid)
                coinIndex.SellOrderId = oid

            else
                Logger:log('Force-close position on TSL/SL; trade amount is not enough: ' .. amount)

                CloseVPosition(cp.close, coinIndex.PositionId)
                coinIndex.IsExcluded = true
            end
        end

        function PTM:updateOrders(coinIndex, forceCancel, allowRemove)
            --local bids = coinIndex.BuyOrderIds
            --local sids = coinIndex.SellOrderIds
            local buyid = coinIndex.BuyOrderId
            local sellid = coinIndex.SellOrderId
            --local remove = {}

            allowRemove = allowRemove or false -- if not set, default to false

            --if Count(bids) == 0 and Count(sids) == 0 then
            if buyid == '' and sellid == '' then
                -- no orders to update
                return
            end

            local filledBuyAmount = 0
            local filledSellAmount = 0

            --------------------------------------------------
            -- Buy orders
                --if Count(bids) > 0 then
                    --Logger:log('Checking BUY orders')

                    --for i = 1, Count(bids) do
                        --local oid = bids[i]
                        local oid = buyid

                        if oid and oid != '' then
                            Logger:log('getting buy order container')
                            Logger:log('oid: ' .. oid)

                            local order = OrderContainer(oid)

                            if not order.isOpen then
                                oid = ''

--[[
                                if allowRemove then
                                    remove = ArrayAdd(remove, i)
                                end
]]

                                -- add filled amount
                                if order.filledAmount > 0 then
                                    coinIndex.AllocatedAmount = coinIndex.AllocatedAmount + order.filledAmount
                                end
                            else
                                if forceCancel then
                                    filledBuyAmount = filledBuyAmount + order.filledAmount

                                    CancelOrder(oid)
                                end
                            end
                        end
                    --end

--[[
                    if Count(remove) > 0 then
                        local temp = bids
                        bids = {}

                        for i = 1, Count(temp) do
                            if not ArrayContains(remove, i) then
                                bids = ArrayAdd(bids, temp[i])
                            end
                        end
                    end
]]

                --end

            --------------------------------------------------
            -- Sell orders
                --remove = {} -- reset array

                --if Count(sids) > 0 then
                    --Logger:log('Checking SELL orders')

                    --for i = 1, Count(sids) do
                        --local oid = sids[i]
                        local oid = sellid

                        if oid and oid != '' then
                            Logger:log('getting sell order container')

                            local order = OrderContainer(oid)

                            if not order.isOpen then
                                oid = ''

--[[
                                if allowRemove then
                                    remove = ArrayAdd(remove, i)
                                end
]]

                                -- subtract filled amount
                                if order.filledAmount > 0 then
                                    coinIndex.AllocatedAmount = coinIndex.AllocatedAmount - order.filledAmount

                                    -- if a sell order is cancelled/filled while
                                    -- SL/TSL is active, we exclude the coin.
                                    --[[ maybe not needed!!
                                    if (coinIndex.StopLossActive
                                    or coinIndex.TrailingStopLossActive)
                                    and (coinIndex.AllocatedAmount < MinimumTradeAmount(coinIndex.Market)
                                    or IsPositionClosed(coinIndex.PositionId))
                                    then
                                        Logger:log('Coin index is now excluded; sold all coins and SL/TSL is active')

                                        coinIndex.IsExcluded = true
                                    end
                                    ]]
                                end
                            else
                                if forceCancel then
                                    filledSellAmount = filledSellAmount + order.filledAmount

                                    CancelOrder(oid)
                                end
                            end
                        end
                    --end

--[[
                    if Count(remove) > 0 then
                        local temp = sids
                        sids = {}

                        for i = 1, Count(temp) do
                            if not ArrayContains(remove, i) then
                                sids = ArrayAdd(sids, temp[i])
                            end
                        end
                    end
]]

                --end


            --if (Count(bids) == 0 and Count(sids) == 0) or not allowRemove then
            if buyid == '' and sellid == '' or not allowRemove then
                coinIndex.IsRelocating = false
            end

            --coinIndex.BuyOrderIds = bids
            --coinIndex.SellOrderIds = sids

            coinIndex.BuyOrderId = buyid
            coinIndex.SellOrderId = sellid

            return filledBuyAmount, filledSellAmount
        end


    -- ---------------------------------------------------------------
    -- Rebalance Method -methods

        function RM:load()

        end

        function RM:individualGrowth()
            OptimizedForInterval(
                rebalanceInterval,
                || Logger:log('Using [Individual Growth] method')
            )
            
            self.Method = function(index)
                
                local cp = CurrentPrice(index.Market)
                local price = index.LastUsedPrice != 0 and index.LastUsedPrice or cp.close

                index.BuyTarget = SubPerc(price, index.BuyThreshold)
                index.SellTarget = AddPerc(price, index.SellThreshold)

                if cp.ask <= index.BuyTarget then
                    -- should buy
                    index.RebalanceSignal = SignalBuy

                    Logger:log('Index should buy; ' .. cp.ask .. ' (ask) <= ' .. index.BuyTarget .. ' (buy target)')

                elseif cp.bid >= index.SellTarget then
                    -- should sell
                    index.RebalanceSignal = SignalSell

                    Logger:log('Index should sell; ' .. cp.bid .. ' (bid) >= ' .. index.SellTarget .. ' (sell target)')

                end
            end
        end

        function RM:portfolioGrowth()
            OptimizedForInterval(
                rebalanceInterval,
                || Logger:log('Using [Portfolio Growth] method')
            )

            self.Method = function(index)

                --local cp = CurrentPrice(index.Market)
                local currentPrc = index.InVirtualWalletBase / Config:getTradeAmount() * 100

                Logger:log('Current %: ' .. Round(currentPrc, 2))

                local sellTarget = index.AllocatedPrc + index.SellThreshold
                local buyTarget = index.AllocatedPrc - index.BuyThreshold

                if currentPrc > sellTarget then
                    index.RebalanceSignal = SignalSell

                    Logger:log('Index should sell; ' .. Round(currentPrc, 2) .. '% > ' .. Round(sellTarget, 2) .. '%')
                
                elseif currentPrc < buyTarget then
                    index.RebalanceSignal = SignalBuy

                    Logger:log('Index should buy; ' .. Round(currentPrc, 2) .. '% < ' .. Round(buyTarget, 2) .. '%')
                end
            end
        end


-----------------------------------------------------------------------------------
-----------------------------------------------------------------------------------
-- SPIDER MODE
        function RM:spider()
            OptimizedForInterval(
                rebalanceInterval,
                || Logger:log('Using [Spider] method')
            )

            -----------------------------------------------------------------------------------
            -- Spider mode price function
            local getPrice = function(coinIndex, isBuy, slotIndex, threshold)
                if not threshold then
                    threshold = isBuy
                            and coinIndex.BuyThreshold
                            or coinIndex.SellThreshold
                end

                local bp = coinIndex.BasePrice
                local p = isBuy
                        and SubPerc(bp, slotIndex * threshold)
                        or AddPerc(bp, slotIndex * threshold)
                
                return p
            end

            local getPrice2 = function(isBuy, basePrice, threshold)
                return isBuy
                        and SubPerc(basePrice, threshold)
                        or AddPerc(basePrice, threshold)
            end


            -----------------------------------------------------------------------------------
            -- Cancel outer buy order and shift array inwards
            local cancelOuterBuy = function(index)
                local oid = index.BuyOrderIds[index.BuyOrders]
                
                if oid and oid != '' then
                    CancelOrder(oid)

                    local orderCount = index.BuyOrders
                    index.BuyOrderIds = Grab(ArrayUnshift(index.BuyOrderIds, ''), 0, orderCount)
                end
            end

            local cancelOuterSell = function(index)
                local oid = index.SellOrderIds[index.SellOrders]

                if oid and oid != '' then
                    CancelOrder(oid)

                    local orderCount = index.SellOrders
                    index.SellOrderIds = Grab(ArrayUnshift(index.SellOrderIds, ''), 0, orderCount)
                end
            end

            -----------------------------------------------------------------------------------
            -- Shift array outwards
            local shiftBuyOutwards = function(index, i)
                index.BuyOrderIds = ArrayAdd(ArrayShift(index.BuyOrderIds), '')

                return ArrayGet(index.BuyOrderIds, 1)
            end

            local shiftSellOutwards = function(index)
                index.SellOrderIds = ArrayAdd(ArrayShift(index.SellOrderIds), '')

                return ArrayGet(index.SellOrderIds, 1)
            end



            local getFilledOrdersAndBasePrice = function(bp, orders)
                Logger:log('executing: getFilledOrdersAndBasePrice()')

                local result = {}
                local len = Count(orders)
                local newbp = bp

                for i = 1, len do
                    local oid = orders[i]
                    local order = OrderContainer(oid)

                    if not order.isOpen
                    and order.filledAmount > 0
                    then
                        result = ArrayAdd(result, oid)

                        if order.isBuyOrder then
                            if newbp < 0 or newbp > order.price then
                                newbp = order.price
                            end
                        elseif order.isSellOrder then
                            if newbp < 0 or newbp < order.price then
                                newbp = order.price
                            end
                        end
                    end
                end

                return result, newbp
            end

            local cancelOuterOrders = function(orders, count)
                Logger:log('executing: cancelOuterOrders()')

                local len = Count(orders)
                local start = len - count

                if start <= 0 then
                    return
                end

                Logger:log('len: ' .. len)
                Logger:log('count: ' .. count)
                Log(orders)

                for i = 1, count do
                    local index = len - (i-1)
                    local oid = orders[index]
                    local order = OrderContainer(oid)

                    if order.isOpen then
                        CancelOrder(oid)
                    end
                end
            end

            local shiftAfterCancel = function(orders, offset, count)
                Logger:log('executing: shiftAfterCancel()')

                local result = orders

                for i = 1, offset do
                    result = ArrayUnshift(result, '')
                end

                return Grab(result, 0, count)
            end


            local cleanOrdersList = function(orders)
                local result = {}

                for i = 1, Count(orders) do
                    local oid = orders[i]
                    local order = OrderContainer(oid)

                    if order.isOpen then
                        result = ArrayAdd(result, oid)
                    end
                end

                return result
            end

            local getOrderPrices = function(orders)
                Logger:log('executing: getOrderPrices()')

                local len = Count(orders)
                local result = {}
                
                for i = 1, len do
                    local oid = orders[i]
                    local order = OrderContainer(oid)

                    result[i] = order.price
                end

                return result
            end

            local refillBuyGrid = function(index, prices)
                Logger:log('executing: refillBuyGrid()')

                local orders = index.BuyOrderIds
                local len = index.BuyOrders
                local allocAmt = index.AllocatedAmount
                local baseAmount = allocAmt
                local exit = false

                prices = prices or {}

                for i = 1, len do
                    local oid = orders[i]
                    local price = prices[i] != nil and prices[i] or getPrice(index, true, i)
                    local amount = baseAmount - SubPerc(baseAmount, index.BuyThreshold)
                    local minimumTradeAmount = MinimumTradeAmount(index.Market, price)

                    -- adjust base amount
                    baseAmount = baseAmount + amount

                    if not oid or oid == '' or not IsOrderOpen(oid) then

                        if IsTradeAmountEnough(index.Market, price, amount, true) then
                            oid = PlaceBuyOrder(price, amount, index.Market, {type = LimitOrderType, timeout = -1, positionId = index.PositionId, note = i})

                        else
                            if not exit then
                                local calculatedMinimum = AddPerc(minimumTradeAmount / allocAmt, 5) * 100
                                
                                Logger:warn('Trade amount is not enough; Buy Threshold is too low')
                                Logger:log('TIP: Calculated minimum threshold is: ' .. Round(calculatedMinimum, 2) .. ' %', Cyan)

                                exit = true
                            end
                            
                        end
                    end

                    orders[i] = oid
                end

                index.BuyOrderIds = orders
            end

            local refillSellGrid = function(index, prices)
                Logger:log('executing: refillSellGrid()')

                local orders = index.SellOrderIds
                local len = index.SellOrders--Count(orders)
                local allocAmt = index.AllocatedAmount
                local baseAmount = allocAmt
                local exit = false

                -- if our lists initial length is 0, use the maximum order count
                --len = len > 0 and len or index.SellOrders

                prices = prices or {}

                for i = 1, len do
                    local oid = orders[i]
                    local price = prices[i] != nil and prices[i] or getPrice(index, false, i)
                    local amount = AddPerc(baseAmount, index.SellThreshold) - baseAmount
                    local minimumTradeAmount = MinimumTradeAmount(index.Market, price)

                    -- adjust base amount
                    baseAmount = baseAmount - amount

                    if not oid or oid == '' or not IsOrderOpen(oid) then
                        --[[
                        Logger:log('baseprice: ' .. index.BasePrice)
                        Logger:log('price: ' .. price)
                        Logger:log('cp.close: ' .. cp.close)
                        Logger:log('amount: ' .. amount .. ' / ' .. minimumTradeAmount)
                        ]]

                        if IsTradeAmountEnough(index.Market, price, amount, true) then
                            oid = PlaceSellOrder(price, amount, index.Market, {type = LimitOrderType, timeout = -1, positionId = index.PositionId, note = i})
                        
                        else
                            if not exit then
                                local calculatedMinimum = AddPerc(minimumTradeAmount / allocAmt, 5) * 100
                                
                                Logger:warn('Trade amount is not enough; Sell Threshold is too low')
                                Logger:log('TIP: Calculated minimum threshold is: ' .. Round(calculatedMinimum, 2) .. ' %', Cyan)
                                
                                exit = true
                            end
                        end
                    end

                    orders[i] = oid
                end

                index.SellOrderIds = orders
            end

            local refillGrids = function(index, boughtPrices, soldPrices)
                refillBuyGrid(index, soldPrices)
                refillSellGrid(index, boughtPrices)
            end



            -----------------------------------------------------------------------------------
            -- Spider mode method
            self.Method = function(index)
                Logger:enter('Spider.Method()')

                local buys = index.BuyOrders
                local sells = index.SellOrders
                local buyOrders = index.BuyOrderIds
                local sellOrders = index.SellOrderIds
                local cp = CurrentPrice(index.Market)
                local allocAmt = index.AllocatedAmount
                local canPlaceOrders = index:canRebalance()
                local newbp = index.BasePrice

                if allocAmt == 0 then
                    Logger:warn('Cannot trade ' .. index.CoinName .. '; current allocated amount is 0. Ignoring coin.')
                    Logger:exit()
                    return
                end

                if ArrayAny(buyOrders) and canPlaceOrders then
                    local filledOrders
                    filledOrders, newbp = getFilledOrdersAndBasePrice(newbp, buyOrders)
                    
                    if ArrayAny(filledOrders) then
                        local fillCount = Count(filledOrders)

                        buyOrders = cleanOrdersList(buyOrders)

                        cancelOuterOrders(sellOrders, fillCount)
                        sellOrders = shiftAfterCancel(sellOrders, fillCount, sells)
                    end
                end

                if ArrayAny(sellOrders) and canPlaceOrders then
                    local filledOrders
                    filledOrders, newbp = getFilledOrdersAndBasePrice(newbp, sellOrders)
                    
                    if ArrayAny(filledOrders) then
                        local fillCount = Count(filledOrders)

                        sellOrders = cleanOrdersList(sellOrders)

                        cancelOuterOrders(buyOrders, fillCount)
                        buyOrders = shiftAfterCancel(buyOrders, fillCount, buys)
                    end
                end

                index.BasePrice = newbp
                index.SellOrderIds = sellOrders
                index.BuyOrderIds = buyOrders

                if canPlaceOrders then
                    refillGrids(index, nil, nil)
                end


                PlotOpenOrders(index)
                Plot(index.ChartId, 'BasePrice', index.BasePrice, Yellow)


                Logger:exit()
            end
        end


-----------------------------------------------------------------------------------
-----------------------------------------------------------------------------------
-- FLASHCRASH MODE
        function RM:flashCrash()
            OptimizedForInterval(
                60,
                || Logger:log('Using [FlashCrash] method')
            )

            --[[
                TODO:

                * need buy and sell orders (index.BuyOrderIds & index.SellOrderIds)
                * buy orders have to be countered with sell orders
                * sell orders have to be countered with buy orders
                * there cannot be more orders than set value (index.BuyOrders & index.SellOrders)


                idea:
                    - use base-price like in spider-mode
                    - when an order fills, take that order price as base price, but
                        preserve the previous base-price in record so can place counter-
                        order on that price
                    - must loop through orders in correct order (in order of fill for example)
                    - when buy order fills, unshift an empty id to sell order list
                    - when sell order fills, unshift an empty id to buy order list
            ]]


            -----------------------------------------------------------------------------------
            -- FlashCrash mode method
            self.Method = function(index)
                Logger:enter('Flash.Method()')

                local market = index.Market
                local cp = CurrentPrice(market)
                local buy_orders = {}
                local sell_orders = {}
                local max_buy_orders = index.BuyOrders
                local max_sell_orders = index.SellOrders
                local buy_thres = index.BuyThreshold
                local sell_thres = index.SellThreshold
                local base_price = index.BasePrice
                local base_amount = Config:getTradeAmount()
                local coin_amount = index.InWallet
                local alloc_prc = index.AllocatedPrc
                local pid = index.PositionId

                local buy_fill_count = Load('aib:fm:bfc', 0)
                local sell_fill_count = Load('aib:fm:sfc', 0)

                if Load('aib:fm:init'..market, true) then
                    Logger:enter('init')
                    -- TODO: init order lists

                    Logger:log('base_amount: ' .. base_amount)
                    Logger:log('coin_amount: ' .. coin_amount)
                    Logger:log('alloc_prc: ' .. alloc_prc)

                    -- place initial buy orders
                    local amt_left = base_amount / base_price
                    for i = 1, max_buy_orders do
                        local price = ArrayGet(SubPerc(base_price, buy_thres * i), 1)
                        local amount = ArrayGet((base_amount - SubPerc(base_amount, alloc_prc)) / price, 1)


                        Logger:log('price buy '..i..': ' .. price)
                        Logger:log('amount buy '..i..': ' .. amount)

                        if amt_left > 0 then
                            if amount > 0 and IsTradeAmountEnough(index.Market, price, amount) then
                                if amt_left - amount > 0 then
                                    --buy_orders[i] = PlaceBuyOrder(price, amount, market, {type = LimitOrderType, note = ''..(-i), timeout = -1, positionId = pid})
                                    
                                    -- negative index for buy slots
                                    local slot = GI:load(index, -i, price, amount)
                                    slot:update()
                                    slot:save()
                                    
                                    amt_left = amt_left - amount
                                else
                                    Logger:warn('Unable to place buy order; not enough '..Config:getBaseCoin())
                                end
                            else
                                Logger:warn('Unable to place buy order; amount is too small ('..amount..' '..index.CoinName..')')
                            end
                        else
                            Logger:warn('Unable to place buy order; not enough base coin left ('..amount..' '..index.CoinName..' required, '..amt_left..' '..index.CoinName..' left)')
                        end
                    end


                    -- place initial sell orders
                    local amt_left = coin_amount
                    for i = 1, max_sell_orders do
                        local price = ArrayGet(AddPerc(base_price, sell_thres * i), 1)
                        local amount = ArrayGet((base_amount - SubPerc(base_amount, alloc_prc)) / price, 1)

                        Logger:log('price sell '..i..': ' .. price)
                        Logger:log('amount sell '..i..': ' .. amount)

                        if amt_left > 0 then
                            if amount > 0 and IsTradeAmountEnough(index.Market, price, amount) then
                                if amt_left - amount > 0 then
                                    --sell_orders[i] = PlaceSellOrder(price, amount, market, {type = LimitOrderType, note = ''..(-i), timeout = -1, positionId = pid})

                                    -- positive index for sell slots
                                    local slot = GI:load(index, i, price, amount)
                                    slot:update()
                                    slot:save()
                                    
                                    amt_left = amt_left - amount
                                else
                                    Logger:warn('Unable to place sell order; not enough '..index.CoinName)
                                end
                            else
                                Logger:warn('Unable to place sell order; amount is too small ('..amount..' '..index.CoinName..')')
                            end
                        else
                            Logger:warn('Unable to place sell order; not enough coins left ('..amount..' '..index.CoinName..' required, '..amt_left..' '..index.CoinName..' left)')
                        end
                    end


                    Save('aib:fm:init'..market, false)
                    Logger:exit()
                else
                    Logger:enter('update')
                    -- TODO: update order lists

                    --[[
                        everything has to be done in a single loop:
                          if order has been filled:
                            * place counter order on current base price
                            * update base price to the filled order price
                    ]]

                    -- WONT WORK LIKE THAT. need to create Grid Items and make them contain
                    -- their own individual positions for proper profit calculations...
                    -- also need individual positions for easier counter-orders ("exits")

                    for i = 1, max_buy_orders do
                        local slot = GI:load(index, -i, 0, 0)
                        slot:update()
                        slot:save()
                    end

                    for i = 1, max_sell_orders do
                        local slot = GI:load(index, i, 0, 0)
                        slot:update()
                        slot:save()
                    end

                    Logger:exit()

                end

                

                --index.BuyOrderIds = buy_orders
                --index.SellOrderIds = sell_orders

                PlotOpenOrders(index)


                Save('aib:fm:bfc', buy_fill_count)
                Save('aib:fm:sfc', sell_fill_count)

                Logger:exit()
            end
        end


        function RM:check(index)
            Logger:enter('RM:check()')
            
            StartTimer('RM:methodTime')

            -- run the method
            self.Method(index)

            local methodElapsed = StopTimer('RM:methodTime')

            --Logger:log('methodTime: ' .. methodElapsed .. ' ms')

            --Logger:log('rebalance signal: '..index.RebalanceSignal)

            if (Config:isIndividualMode()
            or Config:isPortfolioMode())
            and index.RebalanceSignal != SignalNone
            then
                self:rebalance(index)
            end

            Logger:exit()
        end

        function RM:rebalance(index)
            
            Logger:enter('rebalance')
            Logger:log('attempting to rebalance '..index.CoinName)

            if not (index.IsRelocating and index.IsExcluded) then

                local allocAmt = index.AllocatedAmount
                local targetAmt = index.TargetAmount

                Logger:log('current allocation: '..allocAmt)
                Logger:log('target amount: ' ..targetAmt)

                if index.RebalanceSignal == SignalBuy then
                    PTM:buy(index, targetAmt - allocAmt, Config:getRebalanceOrderType())

                elseif index.RebalanceSignal == SignalSell then
                    PTM:sell(index, allocAmt - targetAmt, Config:getRebalanceOrderType())
                    
                end
            else
                Logger:log('Index is relocating or excluded; not executing rebalance.')
            end
        end


-- skip first update
if Load('wait', true) then
    Save('wait', false)
    return
end

StartTimer('Main:totalTime')

-- init configs
Config:init()

-- check configs
if not Config:checkSettings() then
    Logger:error('Execution blocked: One of more errors occurred.')
    return
end

-- init modules
RM:init()
PTM:init()
CIM:init()


-- load modules
CIM:load()
RM:load()
PTM:load()


-- set correct rebalance method
if Config:isIndividualMode() then
    RM:individualGrowth()
elseif Config:isPortfolioMode() then
    RM:portfolioGrowth()
elseif Config:isSpiderMode() then
    RM:spider()
elseif Config:isFlashMode() then
    RM:flashCrash()
end


-- Run
CIM:updateAll() 


local totalElapsed = StopTimer('Main:totalTime')

Logger:log('totalTime: ' .. totalElapsed .. ' ms')