-- Simple Managed Mad Hatter Bot (Manual Position Management)

-- 1. Input Parameters
InputGroupHeader('Mad Hatter Settings')
stopLossPercent = Input('Stop Loss (%)', 5, 'Percentage below entry price to trigger a stop loss.')
takeProfitPercent = Input('Take Profit (%)', 5, 'Percentage above entry price to trigger a take profit.')
indicatorConsensus = Input('Indicator Consensus', true, 'True: Requires 2 out of 3 indicators to agree. False: Any single indicator signal is enough.')
startWithBaseCurrency = Input('Start with Base Currency', false, 'If true, the bot assumes you start with the base currency (e.g., BTC if BTC/USDT) and will look to sell first. If false, it assumes you start with the quote currency (e.g., USDT) and will look to buy first.')

-- Trading Amounts
-- For spot trading, you typically buy/sell with a fixed amount of base or quote currency.
-- For futures/margin, it's often a fixed contract amount or a percentage of equity.
-- Let's use a percentage of available balance for simplicity, but you can adjust.
tradePercentage = Input('Trade Percentage of Balance (%)', 100, 'Percentage of available balance to use for trades.')
minTradeAmountQuote = Input('Minimum Quote Trade Amount', 10, 'Minimum trade amount in quote currency (e.g., USDT) to prevent tiny trades.')


-- 2. Indicator Definitions
-- These variables will hold the raw signal results from the Mad Hatter indicators.
local bbandResult = CC_MadHatterBBands(0, 'BBands')
local macdResult = CC_MadHatterMACD(1, 'MACD')
local rsiResult = CC_MadHatterRSI(2, 'RSI')

-- 3. Combine Indicator Signals for Entry/Exit Logic
local primarySignal = SignalNone -- Default to no signal

if indicatorConsensus then
    -- GetConsensusSignal requires at least 2 of 3 inputs to agree for a signal.
    primarySignal = GetConsensusSignal(bbandResult, macdResult, rsiResult)
else
    -- If no consensus, check if ANY single indicator gives a strong signal.
    if bbandResult == SignalLong or macdResult == SignalLong or rsiResult == SignalLong then
        primarySignal = SignalLong
    elseif bbandResult == SignalShort or macdResult == SignalShort or rsiResult == SignalShort then
        primarySignal = SignalShort
    end
end

-- 4. Get Current Position Information
local longAmount = GetPositionAmount(true)   -- Current long position amount
local shortAmount = GetPositionAmount(false) -- Current short position amount

-- Get current profit/loss as a percentage
local longROI = GetPositionROI(true)
local shortROI = GetPositionROI(false)

-- 5. Define Safeties (Manually checked)
-- StopLoss and TakeProfit functions return boolean true if triggered for a specific position
local longStopLossTriggered = StopLoss(stopLossPercent, true)
local longTakeProfitTriggered = TakeProfit(takeProfitPercent, true)

local shortStopLossTriggered = StopLoss(stopLossPercent, false)
local shortTakeProfitTriggered = TakeProfit(takeProfitPercent, false)

-- 6. Define Insurances (Manually checked)
-- OvercomeFeeCosts() returns true if the current profit covers fees.
local canTradeBecauseFeesCovered = OvercomeFeeCosts() -- Applied globally, or specify positionId if desired

-- 7. Trading Logic (Manual Entry and Exit)
-- --- Exit Logic First (Prioritize exiting positions) ---

-- Handle Long Position Exits
if longAmount > 0 then
    -- Exit conditions for a Long Position
    if longStopLossTriggered then
        Log('STOP LOSS Triggered for Long Position! Exiting.', Red)
        PlaceExitPositionOrder(true, {type = PriceMarket}) -- Exit entire long position at Pricemarket price
    elseif longTakeProfitTriggered then
        Log('TAKE PROFIT Triggered for Long Position! Exiting.', Green)
        PlaceExitPositionOrder(true, {type = PriceMarket})
    elseif primarySignal == SignalShort then
        Log('Indicator Signal SHORT, exiting Long Position.', Yellow)
        PlaceExitPositionOrder(true, {type = PriceMarket})
    end

-- Handle Short Position Exits
elseif shortAmount > 0 then
    -- Exit conditions for a Short Position
    if shortStopLossTriggered then
        Log('STOP LOSS Triggered for Short Position! Exiting.', Red)
        PlaceExitPositionOrder(false, {type = PriceMarket}) -- Exit entire short position at Pricemarket price
    elseif shortTakeProfitTriggered then
        Log('TAKE PROFIT Triggered for Short Position! Exiting.', Green)
        PlaceExitPositionOrder(false, {type = PriceMarket})
    elseif primarySignal == SignalLong then
        Log('Indicator Signal LONG, exiting Short Position.', Yellow)
        PlaceExitPositionOrder(false, {type = PriceMarket})
    end

-- --- Entry Logic (Only if no position open) ---
else -- No long or short position currently open
    local currentPrice = CurrentPrice() -- Get current Pricemarket price

    -- Calculate trade amount based on available balance and percentage
    local tradeAmountBase = WalletAmount(BaseCurrency()) * (tradePercentage / 100)
    local tradeAmountQuote = WalletAmount(QuoteCurrency()) * (tradePercentage / 100)
    
    -- Ensure we trade at least the minimum quote amount, converting to base if needed for buying
    local minAmountInBase = minTradeAmountQuote / currentPrice

    -- Determine the final amount to use for the trade
    local amountToTrade
    
    if startWithBaseCurrency then
        -- If starting with Base Currency, we're looking to SELL (Go Short)
        -- We'll sell from our Base Currency balance
        amountToTrade = math.max(tradeAmountBase, minAmountInBase) -- Use at least minAmountInBase for shorting/selling
        Log('Starting with Base Currency: Looking for SHORT entry.', Cyan)
        
        if primarySignal == SignalShort and amountToTrade > 0 and canTradeBecauseFeesCovered then
            Log('Combined Signal SHORT. Entering Short Position with amount: ' .. amountToTrade, Red)
            -- Use PlaceSellOrder for spot, PlaceGoShortOrder for margin/futures
            PlaceGoShortOrder(amountToTrade, currentPrice, {type = PriceMarket}) -- Assuming PriceMarket order for simplicity
        end
    else
        -- If starting with Quote Currency, we're looking to BUY (Go Long)
        -- We'll buy with our Quote Currency balance
        amountToTrade = math.max(tradeAmountQuote / currentPrice, minAmountInBase) -- Convert quote amount to base amount
        Log('Starting with Quote Currency: Looking for LONG entry.', Cyan)

        if primarySignal == SignalLong and amountToTrade > 0 and canTradeBecauseFeesCovered then
            Log('Combined Signal LONG. Entering Long Position with amount: ' .. amountToTrade, DarkGreen)
            -- Use PlaceBuyOrder for spot, PlaceGoLongOrder for margin/futures
            PlaceGoLongOrder(amountToTrade, currentPrice, {type = PriceMarket}) -- Assuming PriceMarket order for simplicity
        end
    end

    if amountToTrade <= 0 then
        Log('Calculated trade amount is zero or negative. Cannot place order.', Red)
    end
end

-- 8. Custom Reports (for monitoring bot activity)
Finalize(function()
   CustomReport('BBands Signal', tostring(bbandResult))
   CustomReport('MACD Signal', tostring(macdResult))
   CustomReport('RSI Signal', tostring(rsiResult))
   CustomReport('Combined Signal', tostring(primarySignal))
   CustomReport('Stop Loss (%)', stopLossPercent)
   CustomReport('Take Profit (%)', takeProfitPercent)
   CustomReport('Starts with Base Currency', startWithBaseCurrency)
   
   CustomReport('Current Long Position Amount', GetPositionAmount(true))
   CustomReport('Current Long Position ROI', GetPositionROI(true))
   CustomReport('Current Short Position Amount', GetPositionAmount(false))
   CustomReport('Current Short Position ROI', GetPositionROI(false))

   -- Report on safety and insurance states
   CustomReport('Long SL Triggered', longStopLossTriggered)
   CustomReport('Long TP Triggered', longTakeProfitTriggered)
   CustomReport('Short SL Triggered', shortStopLossTriggered)
   CustomReport('Short TP Triggered', shortTakeProfitTriggered)
   CustomReport('Fees Covered for Trade', canTradeBecauseFeesCovered)
end)

-- No TradeBotContainer is used here. Trading is done directly via Place...Order commands
-- in the main script logic, which is run by HaasOnline's engine on each tick/interval.