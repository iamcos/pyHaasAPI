# pyHaasAPI v2 – Cursor Development Rules (Authoritative)

## Purpose
This rules file governs day-to-day development in this repository. The project is a fully functional advanced API toolset (v2). We build and test against live HaasOnline servers via the ServerManager. We integrate new features directly into the existing v2 architecture without creating random scripts or stray files.

## Ground Truths
- Main project: `pyHaasAPI/` (v2). All work happens here.
- We use PHP endpoints (v1-style filenames) from the v2 runtime. Endpoints are already correctly named in code.
- No v1 runtime and no fallbacks. v2 only.
- Servers are online 24/7 and reachable through the `ServerManager`. If something fails, it is a code problem, not a server problem.
- Primary server for testing: srv03 via the SSH tunnel managed by `ServerManager`.
- Always run Python inside `.venv`. Do not modify the environment or add new dependencies unless explicitly approved.
- Never use mocks. All operations use real servers and real data.
- **CRITICAL**: Labs 100% have backtests in them. If the API returns no backtests, it's a code parsing issue, not a data issue.

## Scope & Where to Work
- Implement functionality inside `pyHaasAPI/api/**` and related layers: `core/`, `services/`, `models/`, `exceptions/`, `config/`, and existing CLIs in `cli/`.
- Prefer extending existing modules/classes over adding new files. Only create a new module when there is a clear, reusable abstraction that fits the architecture.
- Keep CLIs thin; primary logic belongs in API/services, not CLI wrappers.
- Do not add one-off scripts. Integrate code into the library/CLI structure.

## Connectivity & Execution Discipline
- Connectivity goes through `pyHaasAPI/core/server_manager.py:ServerManager`.
  - Use `ServerManager.ensure_srv03_tunnel()` and `preflight_check()` for tunnel availability.
  - Single-tunnel policy: only `8090` and `8092` forwarded to `127.0.0.1`.
- Before any test run or long execution: kill stray Python processes, then run with a timeout.
  - Kill: `pkill -f python || true`
  - Use timeouts for all runs (e.g., `timeout 30 python -m ...`) or in-code `signal.alarm()` wrappers.
- If orchestration stalls, use bounded timers and safe cancellation, then restart. Never spin indefinitely.

## API Calling Conventions (PHP endpoints)
- Call explicit PHP endpoints via the async client:
  - `pyHaasAPI/core/client.py:AsyncHaasClient.execute(endpoint="/LabsAPI.php", ...)`
  - Prefer `get_json`/`post_json`/`request_json` helpers when not using `execute`.
- Include required auth parameters (`userid`, `interfacekey`) in query/data as established in the codebase.
- Honor endpoint channels via `query_params={"channel": "..."}`.

## Authentication & Config
- Use `pyHaasAPI/core/auth.py:AuthenticationManager` with `pyHaasAPI/config/api_config.py:APIConfig`.
- Credentials come from env: `API_EMAIL`, `API_PASSWORD`. Connection is `127.0.0.1:8090` per `APIConfig`.
- For CLIs, connect via `pyHaasAPI/cli/base.py:BaseCLI.connect()`; main entry is `pyHaasAPI/cli/main.py`.

## Data Modeling & Field Mapping (Critical)
- API responses are objects or object-like; do not use `.get()` on them.
- Use `hasattr()` checks and `getattr(obj, "field", default)` access. Provide meaningful defaults.
- Validate presence of critical fields before use and log when missing.
- Pydantic models must align with server field names via `alias` (e.g., `UID`, `LID`, `SID`, `N`, `EC`, `ET`, `AID`).
- Validate integer-coded statuses; avoid string `.upper()` assumptions.

## Reliability & Timeouts
- Enforce timeouts and retries using core utilities:
  - `AsyncHaasClient` request `timeout` and `RetryHandler` with exponential backoff.
  - `pyHaasAPI/core/async_client.py:AsyncHaasClientWrapper` and `pyHaasAPI/core/async_utils.py` for bounded timers and batch processing.
- Long-running tasks must report progress and have cancel/abort logic.
- Add iteration/time caps with clear exit conditions. No unbounded loops.

## Testing Expectations (srv03, no mocks)
- Test against srv03 with real data via the mandated tunnel.
- Kill Python processes before tests; always run inside `.venv`.
- Use timeouts for ALL commands to prevent hanging.
- You may create/clone/edit/delete labs, bots, scripts, and other resources as needed for testing. Be deliberate and consistent.
- Success is determined by code achieving its goals against live servers.

## Architecture & Code Quality
- Respect layers: `core/` → `api/` → `services/` → `cli/`.
  - Core: `client.py`, `auth.py`, `server_manager.py`, `async_*` utilities, `config/api_config.py`.
  - API: `api/*/*_api.py` modules (e.g., `BacktestAPI`, `AccountAPI`, `LabAPI`, `ScriptAPI`, `MarketAPI`, `OrderAPI`).
  - Services: Orchestration across APIs (e.g., `services/backtest/backtest_service.py:BacktestService`).
  - CLI: Thin wrappers (`pyHaasAPI/cli/base.py`, `pyHaasAPI/cli/main.py`).
- Reuse existing patterns (fetching, pagination, retries, auth handoff) or refactor to centralize. Avoid duplication.
- Keep code readable, well-typed, and defensive. Avoid deep nesting and unnecessary try/catch.
- Do not add new dependencies unless strictly necessary and approved. Prefer internal utilities.

## Implementation Guidance
- Extend established modules/services. Keep APIs async-first where applicable.
- Ensure new functions have clear inputs/outputs and timeouts. Provide concise, actionable error messages with remediation hints.
- Log field mapping issues, unexpected response shapes, and timeouts with enough context to debug.
- Persist/cache using existing managers/utilities; do not create parallel systems.

## Server/Tunnel Rules (Enforced)
- Single SSH tunnel policy: expose remote Haas API and auxiliary port on localhost 8090 and 8092 only.
- Point clients at `host=127.0.0.1`, `port=8090` (or 8092 where appropriate).
- Preflight checks: CLIs and services must verify tunnel availability before proceeding and fail fast if missing.

## v2-Only Runtime Policy
- No v1 runtime imports in CLI/services.
- No v1 fallbacks. If v2 path fails, fix v2. Do not fall back to v1.
- Guard/log any accidental v1 usage.

## Field Access Safety (Mandatory)
- Never call `.get()` on API response objects.
- Always use `getattr`/`hasattr` with defaults.
- Validate existence before nested access; log missing fields.
- Provide fallbacks for critical fields:
  - `market_tag` / `marketTag`
  - `account_id` / `accountId`
  - `script_id` / `scriptId`
  - `status`
  - `leverage`
  - `position_mode` / `positionMode`
  - `margin_mode` / `marginMode`

## Execution & CLI Discipline
- Run only Python modules; do not introduce ad-hoc shell scripts for core logic.
- Always integrate new capabilities into `pyHaasAPI/` modules and existing CLIs.
- Keep CLIs thin; call services/APIs. Ensure `ServerManager.preflight_check()` is called in CLIs before work.

## Performance & Analysis Standards
- Primary performance metric: ROE (Return on Equity); not ROI. Compute from raw trade data where relevant.
- Use centralized fetchers/managers when available (e.g., unified backtest fetching). Avoid anti-patterns like huge `page_lenght` values.
- Prefer generators/streaming for large datasets; honor pagination.

## Operational Snippets (Consistency)
- Activate and run:
  - `source .venv/bin/activate && pkill -f python || true && timeout 30 python -m pyHaasAPI.cli <cmd>`
- In-code: use bounded retries, explicit timeouts, safe cancellation.

## Common API Error Patterns
- **GET vs POST Issue**: If API returns empty data (Data: null) or fails silently, check if using GET instead of POST. HaasOnline API requires POST with form-urlencoded data in body for most endpoints, NOT GET with query params.
- **Missing Auth Parameters**: All LabsAPI.php calls must include `userid` and `interfacekey` in the POST body.
- **Channel Parameter**: Can be in query params (`?channel=X`) OR in POST body, prefer query params for clarity.

## Prohibitions
- No mock connections. No fake data.
- Do not blame servers, tunnels, or the virtual environment. Problems are in the code.
- Do not create a proliferation of random files or one-off scripts.
- Do not implement unbounded loops or indefinite waits.

## Comprehensive Download System (CRITICAL)
- **Download CLI**: `python -m pyHaasAPI.cli.main download everything` - Downloads ALL backtests from ALL servers
- **Multi-Server Support**: Automatically connects to srv02 (port 8090) and srv03 (port 8091) with tunnel management
- **Complete Data Extraction**: Downloads every single backtest with full metrics (ROI, ROE, trades, profits, etc.)
- **No Pagination Limits**: Uses max_pages=1000 to ensure complete data capture
- **Comprehensive Output**: Saves to timestamped JSON files with complete metadata
- **CLI Integration**: Fully integrated into main CLI with subcommands:
  - `download everything` - All servers, all labs, all backtests
  - `download server <name>` - Specific server only
  - `download lab <id>` - Specific lab only
- **Production Ready**: Handles authentication, tunnel management, error recovery, and cleanup
- **Data Quality**: Extracts 20+ metrics per backtest including performance ratios and trade statistics

## Definition of Done
- The feature integrates cleanly into the architecture.
- Uses PHP endpoints correctly via v2 abstractions (`AsyncHaasClient.execute`).
- Respects timeouts/retries and field safety rules.
- Tested end-to-end on srv03 via `ServerManager` with real data.
- Produces expected outcomes without ad-hoc workarounds.
- **Download system successfully extracts 1000+ backtests per lab from multiple servers.**